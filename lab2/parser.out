Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ADDASSIGN
    BREAK
    COMMENT
    CONTINUE
    DIVASSIGN
    DOTADD
    DOTDIV
    DOTMUL
    DOTSUB
    ELSE
    MULASSIGN
    NOTEQUALS
    PRINT
    STRING
    SUBASSIGN
    THEN
    WHILE
    return

Grammar

Rule 0     S' -> program
Rule 1     program -> instructions_opt
Rule 2     instructions_opt -> instructions
Rule 3     instructions_opt -> <empty>
Rule 4     instructions_block -> { instructions }
Rule 5     instructions -> instructions instruction
Rule 6     instructions -> instruction
Rule 7     instruction -> assignment ;
Rule 8     instruction -> if_instruction
Rule 9     if_instruction -> IF ( relational_expr ) instructions_block
Rule 10    assignment -> ID = INTNUM
Rule 11    assignment -> ID = FLONUM
Rule 12    assignment -> ID = matrix
Rule 13    assignment -> ID = expr
Rule 14    assignment -> MID = INTNUM
Rule 15    expr -> expr + term
Rule 16    expr -> expr - term
Rule 17    expr -> term
Rule 18    term -> term * factor
Rule 19    term -> term / factor
Rule 20    term -> factor
Rule 21    factor -> ( expr )
Rule 22    factor -> ID
Rule 23    relational_expr -> ID GREATEREQUAL INTNUM
Rule 24    relational_expr -> ID EQUALS INTNUM
Rule 25    relational_expr -> ID LOWEREQUAL INTNUM
Rule 26    MID -> ID [ INTNUM , INTNUM ]
Rule 27    matrix -> [ outerlist ]
Rule 28    matrix -> ONES ( INTNUM )
Rule 29    matrix -> ZEROS ( INTNUM )
Rule 30    matrix -> EYE ( INTNUM )
Rule 31    outerlist -> outerlist ; innerlist
Rule 32    outerlist -> innerlist
Rule 33    innerlist -> innerlist , elem
Rule 34    innerlist -> elem
Rule 35    elem -> ID
Rule 36    elem -> INTNUM
Rule 37    elem -> FLONUM

Terminals, with rules where they appear

(                    : 9 21 28 29 30
)                    : 9 21 28 29 30
*                    : 18
+                    : 15
,                    : 26 33
-                    : 16
/                    : 19
;                    : 7 31
=                    : 10 11 12 13 14
ADDASSIGN            : 
BREAK                : 
COMMENT              : 
CONTINUE             : 
DIVASSIGN            : 
DOTADD               : 
DOTDIV               : 
DOTMUL               : 
DOTSUB               : 
ELSE                 : 
EQUALS               : 24
EYE                  : 30
FLONUM               : 11 37
GREATEREQUAL         : 23
ID                   : 10 11 12 13 22 23 24 25 26 35
IF                   : 9
INTNUM               : 10 14 23 24 25 26 26 28 29 30 36
LOWEREQUAL           : 25
MULASSIGN            : 
NOTEQUALS            : 
ONES                 : 28
PRINT                : 
STRING               : 
SUBASSIGN            : 
THEN                 : 
WHILE                : 
ZEROS                : 29
[                    : 26 27
]                    : 26 27
error                : 
return               : 
{                    : 4
}                    : 4

Nonterminals, with rules where they appear

MID                  : 14
assignment           : 7
elem                 : 33 34
expr                 : 13 15 16 21
factor               : 18 19 20
if_instruction       : 8
innerlist            : 31 32 33
instruction          : 5 6
instructions         : 2 4 5
instructions_block   : 9
instructions_opt     : 1
matrix               : 12
outerlist            : 27 31
program              : 0
relational_expr      : 9
term                 : 15 16 17 18 19

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . instructions_opt
    (2) instructions_opt -> . instructions
    (3) instructions_opt -> .
    (5) instructions -> . instructions instruction
    (6) instructions -> . instruction
    (7) instruction -> . assignment ;
    (8) instruction -> . if_instruction
    (10) assignment -> . ID = INTNUM
    (11) assignment -> . ID = FLONUM
    (12) assignment -> . ID = matrix
    (13) assignment -> . ID = expr
    (14) assignment -> . MID = INTNUM
    (9) if_instruction -> . IF ( relational_expr ) instructions_block
    (26) MID -> . ID [ INTNUM , INTNUM ]

    $end            reduce using rule 3 (instructions_opt -> .)
    ID              shift and go to state 7
    IF              shift and go to state 9

    program                        shift and go to state 1
    instructions_opt               shift and go to state 2
    instructions                   shift and go to state 3
    instruction                    shift and go to state 4
    assignment                     shift and go to state 5
    if_instruction                 shift and go to state 6
    MID                            shift and go to state 8

state 1

    (0) S' -> program .



state 2

    (1) program -> instructions_opt .

    $end            reduce using rule 1 (program -> instructions_opt .)


state 3

    (2) instructions_opt -> instructions .
    (5) instructions -> instructions . instruction
    (7) instruction -> . assignment ;
    (8) instruction -> . if_instruction
    (10) assignment -> . ID = INTNUM
    (11) assignment -> . ID = FLONUM
    (12) assignment -> . ID = matrix
    (13) assignment -> . ID = expr
    (14) assignment -> . MID = INTNUM
    (9) if_instruction -> . IF ( relational_expr ) instructions_block
    (26) MID -> . ID [ INTNUM , INTNUM ]

    $end            reduce using rule 2 (instructions_opt -> instructions .)
    ID              shift and go to state 7
    IF              shift and go to state 9

    instruction                    shift and go to state 10
    assignment                     shift and go to state 5
    if_instruction                 shift and go to state 6
    MID                            shift and go to state 8

state 4

    (6) instructions -> instruction .

    ID              reduce using rule 6 (instructions -> instruction .)
    IF              reduce using rule 6 (instructions -> instruction .)
    $end            reduce using rule 6 (instructions -> instruction .)
    }               reduce using rule 6 (instructions -> instruction .)


state 5

    (7) instruction -> assignment . ;

    ;               shift and go to state 11


state 6

    (8) instruction -> if_instruction .

    ID              reduce using rule 8 (instruction -> if_instruction .)
    IF              reduce using rule 8 (instruction -> if_instruction .)
    $end            reduce using rule 8 (instruction -> if_instruction .)
    }               reduce using rule 8 (instruction -> if_instruction .)


state 7

    (10) assignment -> ID . = INTNUM
    (11) assignment -> ID . = FLONUM
    (12) assignment -> ID . = matrix
    (13) assignment -> ID . = expr
    (26) MID -> ID . [ INTNUM , INTNUM ]

    =               shift and go to state 12
    [               shift and go to state 13


state 8

    (14) assignment -> MID . = INTNUM

    =               shift and go to state 14


state 9

    (9) if_instruction -> IF . ( relational_expr ) instructions_block

    (               shift and go to state 15


state 10

    (5) instructions -> instructions instruction .

    ID              reduce using rule 5 (instructions -> instructions instruction .)
    IF              reduce using rule 5 (instructions -> instructions instruction .)
    $end            reduce using rule 5 (instructions -> instructions instruction .)
    }               reduce using rule 5 (instructions -> instructions instruction .)


state 11

    (7) instruction -> assignment ; .

    ID              reduce using rule 7 (instruction -> assignment ; .)
    IF              reduce using rule 7 (instruction -> assignment ; .)
    $end            reduce using rule 7 (instruction -> assignment ; .)
    }               reduce using rule 7 (instruction -> assignment ; .)


state 12

    (10) assignment -> ID = . INTNUM
    (11) assignment -> ID = . FLONUM
    (12) assignment -> ID = . matrix
    (13) assignment -> ID = . expr
    (27) matrix -> . [ outerlist ]
    (28) matrix -> . ONES ( INTNUM )
    (29) matrix -> . ZEROS ( INTNUM )
    (30) matrix -> . EYE ( INTNUM )
    (15) expr -> . expr + term
    (16) expr -> . expr - term
    (17) expr -> . term
    (18) term -> . term * factor
    (19) term -> . term / factor
    (20) term -> . factor
    (21) factor -> . ( expr )
    (22) factor -> . ID

    INTNUM          shift and go to state 17
    FLONUM          shift and go to state 18
    [               shift and go to state 21
    ONES            shift and go to state 22
    ZEROS           shift and go to state 24
    EYE             shift and go to state 25
    (               shift and go to state 23
    ID              shift and go to state 16

    matrix                         shift and go to state 19
    expr                           shift and go to state 20
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 13

    (26) MID -> ID [ . INTNUM , INTNUM ]

    INTNUM          shift and go to state 28


state 14

    (14) assignment -> MID = . INTNUM

    INTNUM          shift and go to state 29


state 15

    (9) if_instruction -> IF ( . relational_expr ) instructions_block
    (23) relational_expr -> . ID GREATEREQUAL INTNUM
    (24) relational_expr -> . ID EQUALS INTNUM
    (25) relational_expr -> . ID LOWEREQUAL INTNUM

    ID              shift and go to state 31

    relational_expr                shift and go to state 30

state 16

    (22) factor -> ID .

    *               reduce using rule 22 (factor -> ID .)
    /               reduce using rule 22 (factor -> ID .)
    +               reduce using rule 22 (factor -> ID .)
    -               reduce using rule 22 (factor -> ID .)
    ;               reduce using rule 22 (factor -> ID .)
    )               reduce using rule 22 (factor -> ID .)


state 17

    (10) assignment -> ID = INTNUM .

    ;               reduce using rule 10 (assignment -> ID = INTNUM .)


state 18

    (11) assignment -> ID = FLONUM .

    ;               reduce using rule 11 (assignment -> ID = FLONUM .)


state 19

    (12) assignment -> ID = matrix .

    ;               reduce using rule 12 (assignment -> ID = matrix .)


state 20

    (13) assignment -> ID = expr .
    (15) expr -> expr . + term
    (16) expr -> expr . - term

    ;               reduce using rule 13 (assignment -> ID = expr .)
    +               shift and go to state 32
    -               shift and go to state 33


state 21

    (27) matrix -> [ . outerlist ]
    (31) outerlist -> . outerlist ; innerlist
    (32) outerlist -> . innerlist
    (33) innerlist -> . innerlist , elem
    (34) innerlist -> . elem
    (35) elem -> . ID
    (36) elem -> . INTNUM
    (37) elem -> . FLONUM

    ID              shift and go to state 37
    INTNUM          shift and go to state 38
    FLONUM          shift and go to state 39

    outerlist                      shift and go to state 34
    innerlist                      shift and go to state 35
    elem                           shift and go to state 36

state 22

    (28) matrix -> ONES . ( INTNUM )

    (               shift and go to state 40


state 23

    (21) factor -> ( . expr )
    (15) expr -> . expr + term
    (16) expr -> . expr - term
    (17) expr -> . term
    (18) term -> . term * factor
    (19) term -> . term / factor
    (20) term -> . factor
    (21) factor -> . ( expr )
    (22) factor -> . ID

    (               shift and go to state 23
    ID              shift and go to state 16

    expr                           shift and go to state 41
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 24

    (29) matrix -> ZEROS . ( INTNUM )

    (               shift and go to state 42


state 25

    (30) matrix -> EYE . ( INTNUM )

    (               shift and go to state 43


state 26

    (17) expr -> term .
    (18) term -> term . * factor
    (19) term -> term . / factor

    +               reduce using rule 17 (expr -> term .)
    -               reduce using rule 17 (expr -> term .)
    ;               reduce using rule 17 (expr -> term .)
    )               reduce using rule 17 (expr -> term .)
    *               shift and go to state 44
    /               shift and go to state 45


state 27

    (20) term -> factor .

    *               reduce using rule 20 (term -> factor .)
    /               reduce using rule 20 (term -> factor .)
    +               reduce using rule 20 (term -> factor .)
    -               reduce using rule 20 (term -> factor .)
    ;               reduce using rule 20 (term -> factor .)
    )               reduce using rule 20 (term -> factor .)


state 28

    (26) MID -> ID [ INTNUM . , INTNUM ]

    ,               shift and go to state 46


state 29

    (14) assignment -> MID = INTNUM .

    ;               reduce using rule 14 (assignment -> MID = INTNUM .)


state 30

    (9) if_instruction -> IF ( relational_expr . ) instructions_block

    )               shift and go to state 47


state 31

    (23) relational_expr -> ID . GREATEREQUAL INTNUM
    (24) relational_expr -> ID . EQUALS INTNUM
    (25) relational_expr -> ID . LOWEREQUAL INTNUM

    GREATEREQUAL    shift and go to state 48
    EQUALS          shift and go to state 49
    LOWEREQUAL      shift and go to state 50


state 32

    (15) expr -> expr + . term
    (18) term -> . term * factor
    (19) term -> . term / factor
    (20) term -> . factor
    (21) factor -> . ( expr )
    (22) factor -> . ID

    (               shift and go to state 23
    ID              shift and go to state 16

    term                           shift and go to state 51
    factor                         shift and go to state 27

state 33

    (16) expr -> expr - . term
    (18) term -> . term * factor
    (19) term -> . term / factor
    (20) term -> . factor
    (21) factor -> . ( expr )
    (22) factor -> . ID

    (               shift and go to state 23
    ID              shift and go to state 16

    term                           shift and go to state 52
    factor                         shift and go to state 27

state 34

    (27) matrix -> [ outerlist . ]
    (31) outerlist -> outerlist . ; innerlist

    ]               shift and go to state 53
    ;               shift and go to state 54


state 35

    (32) outerlist -> innerlist .
    (33) innerlist -> innerlist . , elem

    ]               reduce using rule 32 (outerlist -> innerlist .)
    ;               reduce using rule 32 (outerlist -> innerlist .)
    ,               shift and go to state 55


state 36

    (34) innerlist -> elem .

    ,               reduce using rule 34 (innerlist -> elem .)
    ]               reduce using rule 34 (innerlist -> elem .)
    ;               reduce using rule 34 (innerlist -> elem .)


state 37

    (35) elem -> ID .

    ,               reduce using rule 35 (elem -> ID .)
    ]               reduce using rule 35 (elem -> ID .)
    ;               reduce using rule 35 (elem -> ID .)


state 38

    (36) elem -> INTNUM .

    ,               reduce using rule 36 (elem -> INTNUM .)
    ]               reduce using rule 36 (elem -> INTNUM .)
    ;               reduce using rule 36 (elem -> INTNUM .)


state 39

    (37) elem -> FLONUM .

    ,               reduce using rule 37 (elem -> FLONUM .)
    ]               reduce using rule 37 (elem -> FLONUM .)
    ;               reduce using rule 37 (elem -> FLONUM .)


state 40

    (28) matrix -> ONES ( . INTNUM )

    INTNUM          shift and go to state 56


state 41

    (21) factor -> ( expr . )
    (15) expr -> expr . + term
    (16) expr -> expr . - term

    )               shift and go to state 57
    +               shift and go to state 32
    -               shift and go to state 33


state 42

    (29) matrix -> ZEROS ( . INTNUM )

    INTNUM          shift and go to state 58


state 43

    (30) matrix -> EYE ( . INTNUM )

    INTNUM          shift and go to state 59


state 44

    (18) term -> term * . factor
    (21) factor -> . ( expr )
    (22) factor -> . ID

    (               shift and go to state 23
    ID              shift and go to state 16

    factor                         shift and go to state 60

state 45

    (19) term -> term / . factor
    (21) factor -> . ( expr )
    (22) factor -> . ID

    (               shift and go to state 23
    ID              shift and go to state 16

    factor                         shift and go to state 61

state 46

    (26) MID -> ID [ INTNUM , . INTNUM ]

    INTNUM          shift and go to state 62


state 47

    (9) if_instruction -> IF ( relational_expr ) . instructions_block
    (4) instructions_block -> . { instructions }

    {               shift and go to state 64

    instructions_block             shift and go to state 63

state 48

    (23) relational_expr -> ID GREATEREQUAL . INTNUM

    INTNUM          shift and go to state 65


state 49

    (24) relational_expr -> ID EQUALS . INTNUM

    INTNUM          shift and go to state 66


state 50

    (25) relational_expr -> ID LOWEREQUAL . INTNUM

    INTNUM          shift and go to state 67


state 51

    (15) expr -> expr + term .
    (18) term -> term . * factor
    (19) term -> term . / factor

    +               reduce using rule 15 (expr -> expr + term .)
    -               reduce using rule 15 (expr -> expr + term .)
    ;               reduce using rule 15 (expr -> expr + term .)
    )               reduce using rule 15 (expr -> expr + term .)
    *               shift and go to state 44
    /               shift and go to state 45


state 52

    (16) expr -> expr - term .
    (18) term -> term . * factor
    (19) term -> term . / factor

    +               reduce using rule 16 (expr -> expr - term .)
    -               reduce using rule 16 (expr -> expr - term .)
    ;               reduce using rule 16 (expr -> expr - term .)
    )               reduce using rule 16 (expr -> expr - term .)
    *               shift and go to state 44
    /               shift and go to state 45


state 53

    (27) matrix -> [ outerlist ] .

    ;               reduce using rule 27 (matrix -> [ outerlist ] .)


state 54

    (31) outerlist -> outerlist ; . innerlist
    (33) innerlist -> . innerlist , elem
    (34) innerlist -> . elem
    (35) elem -> . ID
    (36) elem -> . INTNUM
    (37) elem -> . FLONUM

    ID              shift and go to state 37
    INTNUM          shift and go to state 38
    FLONUM          shift and go to state 39

    innerlist                      shift and go to state 68
    elem                           shift and go to state 36

state 55

    (33) innerlist -> innerlist , . elem
    (35) elem -> . ID
    (36) elem -> . INTNUM
    (37) elem -> . FLONUM

    ID              shift and go to state 37
    INTNUM          shift and go to state 38
    FLONUM          shift and go to state 39

    elem                           shift and go to state 69

state 56

    (28) matrix -> ONES ( INTNUM . )

    )               shift and go to state 70


state 57

    (21) factor -> ( expr ) .

    *               reduce using rule 21 (factor -> ( expr ) .)
    /               reduce using rule 21 (factor -> ( expr ) .)
    +               reduce using rule 21 (factor -> ( expr ) .)
    -               reduce using rule 21 (factor -> ( expr ) .)
    ;               reduce using rule 21 (factor -> ( expr ) .)
    )               reduce using rule 21 (factor -> ( expr ) .)


state 58

    (29) matrix -> ZEROS ( INTNUM . )

    )               shift and go to state 71


state 59

    (30) matrix -> EYE ( INTNUM . )

    )               shift and go to state 72


state 60

    (18) term -> term * factor .

    *               reduce using rule 18 (term -> term * factor .)
    /               reduce using rule 18 (term -> term * factor .)
    +               reduce using rule 18 (term -> term * factor .)
    -               reduce using rule 18 (term -> term * factor .)
    ;               reduce using rule 18 (term -> term * factor .)
    )               reduce using rule 18 (term -> term * factor .)


state 61

    (19) term -> term / factor .

    *               reduce using rule 19 (term -> term / factor .)
    /               reduce using rule 19 (term -> term / factor .)
    +               reduce using rule 19 (term -> term / factor .)
    -               reduce using rule 19 (term -> term / factor .)
    ;               reduce using rule 19 (term -> term / factor .)
    )               reduce using rule 19 (term -> term / factor .)


state 62

    (26) MID -> ID [ INTNUM , INTNUM . ]

    ]               shift and go to state 73


state 63

    (9) if_instruction -> IF ( relational_expr ) instructions_block .

    ID              reduce using rule 9 (if_instruction -> IF ( relational_expr ) instructions_block .)
    IF              reduce using rule 9 (if_instruction -> IF ( relational_expr ) instructions_block .)
    $end            reduce using rule 9 (if_instruction -> IF ( relational_expr ) instructions_block .)
    }               reduce using rule 9 (if_instruction -> IF ( relational_expr ) instructions_block .)


state 64

    (4) instructions_block -> { . instructions }
    (5) instructions -> . instructions instruction
    (6) instructions -> . instruction
    (7) instruction -> . assignment ;
    (8) instruction -> . if_instruction
    (10) assignment -> . ID = INTNUM
    (11) assignment -> . ID = FLONUM
    (12) assignment -> . ID = matrix
    (13) assignment -> . ID = expr
    (14) assignment -> . MID = INTNUM
    (9) if_instruction -> . IF ( relational_expr ) instructions_block
    (26) MID -> . ID [ INTNUM , INTNUM ]

    ID              shift and go to state 7
    IF              shift and go to state 9

    instructions                   shift and go to state 74
    instruction                    shift and go to state 4
    assignment                     shift and go to state 5
    if_instruction                 shift and go to state 6
    MID                            shift and go to state 8

state 65

    (23) relational_expr -> ID GREATEREQUAL INTNUM .

    )               reduce using rule 23 (relational_expr -> ID GREATEREQUAL INTNUM .)


state 66

    (24) relational_expr -> ID EQUALS INTNUM .

    )               reduce using rule 24 (relational_expr -> ID EQUALS INTNUM .)


state 67

    (25) relational_expr -> ID LOWEREQUAL INTNUM .

    )               reduce using rule 25 (relational_expr -> ID LOWEREQUAL INTNUM .)


state 68

    (31) outerlist -> outerlist ; innerlist .
    (33) innerlist -> innerlist . , elem

    ]               reduce using rule 31 (outerlist -> outerlist ; innerlist .)
    ;               reduce using rule 31 (outerlist -> outerlist ; innerlist .)
    ,               shift and go to state 55


state 69

    (33) innerlist -> innerlist , elem .

    ,               reduce using rule 33 (innerlist -> innerlist , elem .)
    ]               reduce using rule 33 (innerlist -> innerlist , elem .)
    ;               reduce using rule 33 (innerlist -> innerlist , elem .)


state 70

    (28) matrix -> ONES ( INTNUM ) .

    ;               reduce using rule 28 (matrix -> ONES ( INTNUM ) .)


state 71

    (29) matrix -> ZEROS ( INTNUM ) .

    ;               reduce using rule 29 (matrix -> ZEROS ( INTNUM ) .)


state 72

    (30) matrix -> EYE ( INTNUM ) .

    ;               reduce using rule 30 (matrix -> EYE ( INTNUM ) .)


state 73

    (26) MID -> ID [ INTNUM , INTNUM ] .

    =               reduce using rule 26 (MID -> ID [ INTNUM , INTNUM ] .)


state 74

    (4) instructions_block -> { instructions . }
    (5) instructions -> instructions . instruction
    (7) instruction -> . assignment ;
    (8) instruction -> . if_instruction
    (10) assignment -> . ID = INTNUM
    (11) assignment -> . ID = FLONUM
    (12) assignment -> . ID = matrix
    (13) assignment -> . ID = expr
    (14) assignment -> . MID = INTNUM
    (9) if_instruction -> . IF ( relational_expr ) instructions_block
    (26) MID -> . ID [ INTNUM , INTNUM ]

    }               shift and go to state 75
    ID              shift and go to state 7
    IF              shift and go to state 9

    instruction                    shift and go to state 10
    assignment                     shift and go to state 5
    if_instruction                 shift and go to state 6
    MID                            shift and go to state 8

state 75

    (4) instructions_block -> { instructions } .

    ID              reduce using rule 4 (instructions_block -> { instructions } .)
    IF              reduce using rule 4 (instructions_block -> { instructions } .)
    $end            reduce using rule 4 (instructions_block -> { instructions } .)
    }               reduce using rule 4 (instructions_block -> { instructions } .)

