Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> program
Rule 1     program -> instructions_opt
Rule 2     instructions_opt -> instructions
Rule 3     instructions_block -> { instructions }
Rule 4     instructions -> instruction instructions
Rule 5     instructions -> instruction
Rule 6     instruction -> assignment ;
Rule 7     instruction -> if_instruction
Rule 8     instruction -> for_instruction
Rule 9     instruction -> while_instruction
Rule 10    instruction -> print_instruction
Rule 11    instruction -> loop_instruction
Rule 12    instruction -> return_instruction
Rule 13    instruction -> instructions_block
Rule 14    if_instruction -> IF ( relational_expr ) instructions_block
Rule 15    if_instruction -> IF ( relational_expr ) instruction
Rule 16    if_instruction -> IF ( relational_expr ) instructions_block ELSE instruction
Rule 17    if_instruction -> IF ( relational_expr ) instruction ELSE instruction
Rule 18    for_instruction -> FOR ID = int : ID instructions_block
Rule 19    for_instruction -> FOR ID = int : ID instruction
Rule 20    for_instruction -> FOR ID = ID : ID instructions_block
Rule 21    for_instruction -> FOR ID = ID : ID instruction
Rule 22    while_instruction -> WHILE ( relational_expr ) instructions_block
Rule 23    while_instruction -> WHILE ( relational_expr ) instruction
Rule 24    loop_instruction -> BREAK ;
Rule 25    loop_instruction -> CONTINUE ;
Rule 26    return_instruction -> RETURN expr ;
Rule 27    print_instruction -> PRINT args_list ;
Rule 28    args_list -> args_list , expr
Rule 29    args_list -> args_list , string
Rule 30    args_list -> expr
Rule 31    args_list -> string
Rule 32    assignment -> ID = token
Rule 33    assignment -> ID ADDASSIGN token
Rule 34    assignment -> ID SUBASSIGN token
Rule 35    assignment -> ID MULASSIGN token
Rule 36    assignment -> ID DIVASSIGN token
Rule 37    assignment -> MID = elem
Rule 38    token -> ID
Rule 39    token -> int
Rule 40    token -> float
Rule 41    token -> matrix
Rule 42    token -> expr
Rule 43    token -> matrix_expr
Rule 44    token -> unary_expr
Rule 45    expr -> expr + term
Rule 46    expr -> expr - term
Rule 47    expr -> term
Rule 48    term -> term * factor
Rule 49    term -> term / factor
Rule 50    term -> factor
Rule 51    factor -> ( expr )
Rule 52    factor -> elem
Rule 53    relational_expr -> expr GREATEREQUAL expr
Rule 54    relational_expr -> expr EQUALS expr
Rule 55    relational_expr -> expr NOTEQUALS expr
Rule 56    relational_expr -> expr LOWEREQUAL expr
Rule 57    relational_expr -> expr < expr
Rule 58    relational_expr -> expr > expr
Rule 59    MID -> ID [ INTNUM , INTNUM ]
Rule 60    matrix -> [ outerlist ]
Rule 61    matrix -> ONES ( args_list )
Rule 62    matrix -> ZEROS ( args_list )
Rule 63    matrix -> EYE ( args_list )
Rule 64    vector -> [ innerlist ]
Rule 65    outerlist -> outerlist ; innerlist
Rule 66    outerlist -> innerlist
Rule 67    innerlist -> innerlist , elem
Rule 68    innerlist -> elem
Rule 69    innerlist -> <empty>
Rule 70    elem -> ID
Rule 71    elem -> int
Rule 72    elem -> float
Rule 73    matrix_expr -> matrix_expr DOTADD matrix_term
Rule 74    matrix_expr -> matrix_expr DOTSUB matrix_term
Rule 75    matrix_expr -> matrix_term
Rule 76    matrix_term -> matrix_term DOTMUL matrix_factor
Rule 77    matrix_term -> matrix_term DOTDIV matrix_factor
Rule 78    matrix_term -> matrix_factor
Rule 79    matrix_factor -> ( matrix_expr )
Rule 80    matrix_factor -> matrix
Rule 81    matrix_factor -> ID
Rule 82    unary_expr -> - expr
Rule 83    unary_expr -> matrix_expr '
Rule 84    int -> INTNUM
Rule 85    float -> FLONUM
Rule 86    string -> STRING

Terminals, with rules where they appear

'                    : 83
(                    : 14 15 16 17 22 23 51 61 62 63 79
)                    : 14 15 16 17 22 23 51 61 62 63 79
*                    : 48
+                    : 45
,                    : 28 29 59 67
-                    : 46 82
/                    : 49
:                    : 18 19 20 21
;                    : 6 24 25 26 27 65
<                    : 57
=                    : 18 19 20 21 32 37
>                    : 58
ADDASSIGN            : 33
BREAK                : 24
COMMENT              : 
CONTINUE             : 25
DIVASSIGN            : 36
DOTADD               : 73
DOTDIV               : 77
DOTMUL               : 76
DOTSUB               : 74
ELSE                 : 16 17
EQUALS               : 54
EYE                  : 63
FLONUM               : 85
FOR                  : 18 19 20 21
GREATEREQUAL         : 53
ID                   : 18 18 19 19 20 20 20 21 21 21 32 33 34 35 36 38 59 70 81
IF                   : 14 15 16 17
INTNUM               : 59 59 84
LOWEREQUAL           : 56
MULASSIGN            : 35
NOTEQUALS            : 55
ONES                 : 61
PRINT                : 27
RETURN               : 26
STRING               : 86
SUBASSIGN            : 34
WHILE                : 22 23
ZEROS                : 62
[                    : 59 60 64
]                    : 59 60 64
error                : 
{                    : 3
}                    : 3

Nonterminals, with rules where they appear

MID                  : 37
args_list            : 27 28 29 61 62 63
assignment           : 6
elem                 : 37 52 67 68
expr                 : 26 28 30 42 45 46 51 53 53 54 54 55 55 56 56 57 57 58 58 82
factor               : 48 49 50
float                : 40 72
for_instruction      : 8
if_instruction       : 7
innerlist            : 64 65 66 67
instruction          : 4 5 15 16 17 17 19 21 23
instructions         : 2 3 4
instructions_block   : 13 14 16 18 20 22
instructions_opt     : 1
int                  : 18 19 39 71
loop_instruction     : 11
matrix               : 41 80
matrix_expr          : 43 73 74 79 83
matrix_factor        : 76 77 78
matrix_term          : 73 74 75 76 77
outerlist            : 60 65
print_instruction    : 10
program              : 0
relational_expr      : 14 15 16 17 22 23
return_instruction   : 12
string               : 29 31
term                 : 45 46 47 48 49
token                : 32 33 34 35 36
unary_expr           : 44
vector               : 
while_instruction    : 9

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . instructions_opt
    (2) instructions_opt -> . instructions
    (4) instructions -> . instruction instructions
    (5) instructions -> . instruction
    (6) instruction -> . assignment ;
    (7) instruction -> . if_instruction
    (8) instruction -> . for_instruction
    (9) instruction -> . while_instruction
    (10) instruction -> . print_instruction
    (11) instruction -> . loop_instruction
    (12) instruction -> . return_instruction
    (13) instruction -> . instructions_block
    (32) assignment -> . ID = token
    (33) assignment -> . ID ADDASSIGN token
    (34) assignment -> . ID SUBASSIGN token
    (35) assignment -> . ID MULASSIGN token
    (36) assignment -> . ID DIVASSIGN token
    (37) assignment -> . MID = elem
    (14) if_instruction -> . IF ( relational_expr ) instructions_block
    (15) if_instruction -> . IF ( relational_expr ) instruction
    (16) if_instruction -> . IF ( relational_expr ) instructions_block ELSE instruction
    (17) if_instruction -> . IF ( relational_expr ) instruction ELSE instruction
    (18) for_instruction -> . FOR ID = int : ID instructions_block
    (19) for_instruction -> . FOR ID = int : ID instruction
    (20) for_instruction -> . FOR ID = ID : ID instructions_block
    (21) for_instruction -> . FOR ID = ID : ID instruction
    (22) while_instruction -> . WHILE ( relational_expr ) instructions_block
    (23) while_instruction -> . WHILE ( relational_expr ) instruction
    (27) print_instruction -> . PRINT args_list ;
    (24) loop_instruction -> . BREAK ;
    (25) loop_instruction -> . CONTINUE ;
    (26) return_instruction -> . RETURN expr ;
    (3) instructions_block -> . { instructions }
    (59) MID -> . ID [ INTNUM , INTNUM ]

    ID              shift and go to state 13
    IF              shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    PRINT           shift and go to state 18
    BREAK           shift and go to state 19
    CONTINUE        shift and go to state 20
    RETURN          shift and go to state 21
    {               shift and go to state 22

    program                        shift and go to state 1
    instructions_opt               shift and go to state 2
    instructions                   shift and go to state 3
    instruction                    shift and go to state 4
    assignment                     shift and go to state 5
    if_instruction                 shift and go to state 6
    for_instruction                shift and go to state 7
    while_instruction              shift and go to state 8
    print_instruction              shift and go to state 9
    loop_instruction               shift and go to state 10
    return_instruction             shift and go to state 11
    instructions_block             shift and go to state 12
    MID                            shift and go to state 14

state 1

    (0) S' -> program .



state 2

    (1) program -> instructions_opt .

    $end            reduce using rule 1 (program -> instructions_opt .)


state 3

    (2) instructions_opt -> instructions .

    $end            reduce using rule 2 (instructions_opt -> instructions .)


state 4

    (4) instructions -> instruction . instructions
    (5) instructions -> instruction .
    (4) instructions -> . instruction instructions
    (5) instructions -> . instruction
    (6) instruction -> . assignment ;
    (7) instruction -> . if_instruction
    (8) instruction -> . for_instruction
    (9) instruction -> . while_instruction
    (10) instruction -> . print_instruction
    (11) instruction -> . loop_instruction
    (12) instruction -> . return_instruction
    (13) instruction -> . instructions_block
    (32) assignment -> . ID = token
    (33) assignment -> . ID ADDASSIGN token
    (34) assignment -> . ID SUBASSIGN token
    (35) assignment -> . ID MULASSIGN token
    (36) assignment -> . ID DIVASSIGN token
    (37) assignment -> . MID = elem
    (14) if_instruction -> . IF ( relational_expr ) instructions_block
    (15) if_instruction -> . IF ( relational_expr ) instruction
    (16) if_instruction -> . IF ( relational_expr ) instructions_block ELSE instruction
    (17) if_instruction -> . IF ( relational_expr ) instruction ELSE instruction
    (18) for_instruction -> . FOR ID = int : ID instructions_block
    (19) for_instruction -> . FOR ID = int : ID instruction
    (20) for_instruction -> . FOR ID = ID : ID instructions_block
    (21) for_instruction -> . FOR ID = ID : ID instruction
    (22) while_instruction -> . WHILE ( relational_expr ) instructions_block
    (23) while_instruction -> . WHILE ( relational_expr ) instruction
    (27) print_instruction -> . PRINT args_list ;
    (24) loop_instruction -> . BREAK ;
    (25) loop_instruction -> . CONTINUE ;
    (26) return_instruction -> . RETURN expr ;
    (3) instructions_block -> . { instructions }
    (59) MID -> . ID [ INTNUM , INTNUM ]

    $end            reduce using rule 5 (instructions -> instruction .)
    }               reduce using rule 5 (instructions -> instruction .)
    ID              shift and go to state 13
    IF              shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    PRINT           shift and go to state 18
    BREAK           shift and go to state 19
    CONTINUE        shift and go to state 20
    RETURN          shift and go to state 21
    {               shift and go to state 22

    instruction                    shift and go to state 4
    instructions                   shift and go to state 23
    assignment                     shift and go to state 5
    if_instruction                 shift and go to state 6
    for_instruction                shift and go to state 7
    while_instruction              shift and go to state 8
    print_instruction              shift and go to state 9
    loop_instruction               shift and go to state 10
    return_instruction             shift and go to state 11
    instructions_block             shift and go to state 12
    MID                            shift and go to state 14

state 5

    (6) instruction -> assignment . ;

    ;               shift and go to state 24


state 6

    (7) instruction -> if_instruction .

    ID              reduce using rule 7 (instruction -> if_instruction .)
    IF              reduce using rule 7 (instruction -> if_instruction .)
    FOR             reduce using rule 7 (instruction -> if_instruction .)
    WHILE           reduce using rule 7 (instruction -> if_instruction .)
    PRINT           reduce using rule 7 (instruction -> if_instruction .)
    BREAK           reduce using rule 7 (instruction -> if_instruction .)
    CONTINUE        reduce using rule 7 (instruction -> if_instruction .)
    RETURN          reduce using rule 7 (instruction -> if_instruction .)
    {               reduce using rule 7 (instruction -> if_instruction .)
    $end            reduce using rule 7 (instruction -> if_instruction .)
    }               reduce using rule 7 (instruction -> if_instruction .)
    ELSE            reduce using rule 7 (instruction -> if_instruction .)


state 7

    (8) instruction -> for_instruction .

    ID              reduce using rule 8 (instruction -> for_instruction .)
    IF              reduce using rule 8 (instruction -> for_instruction .)
    FOR             reduce using rule 8 (instruction -> for_instruction .)
    WHILE           reduce using rule 8 (instruction -> for_instruction .)
    PRINT           reduce using rule 8 (instruction -> for_instruction .)
    BREAK           reduce using rule 8 (instruction -> for_instruction .)
    CONTINUE        reduce using rule 8 (instruction -> for_instruction .)
    RETURN          reduce using rule 8 (instruction -> for_instruction .)
    {               reduce using rule 8 (instruction -> for_instruction .)
    $end            reduce using rule 8 (instruction -> for_instruction .)
    }               reduce using rule 8 (instruction -> for_instruction .)
    ELSE            reduce using rule 8 (instruction -> for_instruction .)


state 8

    (9) instruction -> while_instruction .

    ID              reduce using rule 9 (instruction -> while_instruction .)
    IF              reduce using rule 9 (instruction -> while_instruction .)
    FOR             reduce using rule 9 (instruction -> while_instruction .)
    WHILE           reduce using rule 9 (instruction -> while_instruction .)
    PRINT           reduce using rule 9 (instruction -> while_instruction .)
    BREAK           reduce using rule 9 (instruction -> while_instruction .)
    CONTINUE        reduce using rule 9 (instruction -> while_instruction .)
    RETURN          reduce using rule 9 (instruction -> while_instruction .)
    {               reduce using rule 9 (instruction -> while_instruction .)
    $end            reduce using rule 9 (instruction -> while_instruction .)
    }               reduce using rule 9 (instruction -> while_instruction .)
    ELSE            reduce using rule 9 (instruction -> while_instruction .)


state 9

    (10) instruction -> print_instruction .

    ID              reduce using rule 10 (instruction -> print_instruction .)
    IF              reduce using rule 10 (instruction -> print_instruction .)
    FOR             reduce using rule 10 (instruction -> print_instruction .)
    WHILE           reduce using rule 10 (instruction -> print_instruction .)
    PRINT           reduce using rule 10 (instruction -> print_instruction .)
    BREAK           reduce using rule 10 (instruction -> print_instruction .)
    CONTINUE        reduce using rule 10 (instruction -> print_instruction .)
    RETURN          reduce using rule 10 (instruction -> print_instruction .)
    {               reduce using rule 10 (instruction -> print_instruction .)
    $end            reduce using rule 10 (instruction -> print_instruction .)
    }               reduce using rule 10 (instruction -> print_instruction .)
    ELSE            reduce using rule 10 (instruction -> print_instruction .)


state 10

    (11) instruction -> loop_instruction .

    ID              reduce using rule 11 (instruction -> loop_instruction .)
    IF              reduce using rule 11 (instruction -> loop_instruction .)
    FOR             reduce using rule 11 (instruction -> loop_instruction .)
    WHILE           reduce using rule 11 (instruction -> loop_instruction .)
    PRINT           reduce using rule 11 (instruction -> loop_instruction .)
    BREAK           reduce using rule 11 (instruction -> loop_instruction .)
    CONTINUE        reduce using rule 11 (instruction -> loop_instruction .)
    RETURN          reduce using rule 11 (instruction -> loop_instruction .)
    {               reduce using rule 11 (instruction -> loop_instruction .)
    $end            reduce using rule 11 (instruction -> loop_instruction .)
    }               reduce using rule 11 (instruction -> loop_instruction .)
    ELSE            reduce using rule 11 (instruction -> loop_instruction .)


state 11

    (12) instruction -> return_instruction .

    ID              reduce using rule 12 (instruction -> return_instruction .)
    IF              reduce using rule 12 (instruction -> return_instruction .)
    FOR             reduce using rule 12 (instruction -> return_instruction .)
    WHILE           reduce using rule 12 (instruction -> return_instruction .)
    PRINT           reduce using rule 12 (instruction -> return_instruction .)
    BREAK           reduce using rule 12 (instruction -> return_instruction .)
    CONTINUE        reduce using rule 12 (instruction -> return_instruction .)
    RETURN          reduce using rule 12 (instruction -> return_instruction .)
    {               reduce using rule 12 (instruction -> return_instruction .)
    $end            reduce using rule 12 (instruction -> return_instruction .)
    }               reduce using rule 12 (instruction -> return_instruction .)
    ELSE            reduce using rule 12 (instruction -> return_instruction .)


state 12

    (13) instruction -> instructions_block .

    ID              reduce using rule 13 (instruction -> instructions_block .)
    IF              reduce using rule 13 (instruction -> instructions_block .)
    FOR             reduce using rule 13 (instruction -> instructions_block .)
    WHILE           reduce using rule 13 (instruction -> instructions_block .)
    PRINT           reduce using rule 13 (instruction -> instructions_block .)
    BREAK           reduce using rule 13 (instruction -> instructions_block .)
    CONTINUE        reduce using rule 13 (instruction -> instructions_block .)
    RETURN          reduce using rule 13 (instruction -> instructions_block .)
    {               reduce using rule 13 (instruction -> instructions_block .)
    $end            reduce using rule 13 (instruction -> instructions_block .)
    }               reduce using rule 13 (instruction -> instructions_block .)
    ELSE            reduce using rule 13 (instruction -> instructions_block .)


state 13

    (32) assignment -> ID . = token
    (33) assignment -> ID . ADDASSIGN token
    (34) assignment -> ID . SUBASSIGN token
    (35) assignment -> ID . MULASSIGN token
    (36) assignment -> ID . DIVASSIGN token
    (59) MID -> ID . [ INTNUM , INTNUM ]

    =               shift and go to state 25
    ADDASSIGN       shift and go to state 26
    SUBASSIGN       shift and go to state 27
    MULASSIGN       shift and go to state 28
    DIVASSIGN       shift and go to state 29
    [               shift and go to state 30


state 14

    (37) assignment -> MID . = elem

    =               shift and go to state 31


state 15

    (14) if_instruction -> IF . ( relational_expr ) instructions_block
    (15) if_instruction -> IF . ( relational_expr ) instruction
    (16) if_instruction -> IF . ( relational_expr ) instructions_block ELSE instruction
    (17) if_instruction -> IF . ( relational_expr ) instruction ELSE instruction

    (               shift and go to state 32


state 16

    (18) for_instruction -> FOR . ID = int : ID instructions_block
    (19) for_instruction -> FOR . ID = int : ID instruction
    (20) for_instruction -> FOR . ID = ID : ID instructions_block
    (21) for_instruction -> FOR . ID = ID : ID instruction

    ID              shift and go to state 33


state 17

    (22) while_instruction -> WHILE . ( relational_expr ) instructions_block
    (23) while_instruction -> WHILE . ( relational_expr ) instruction

    (               shift and go to state 34


state 18

    (27) print_instruction -> PRINT . args_list ;
    (28) args_list -> . args_list , expr
    (29) args_list -> . args_list , string
    (30) args_list -> . expr
    (31) args_list -> . string
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (86) string -> . STRING
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float
    (84) int -> . INTNUM
    (85) float -> . FLONUM

    STRING          shift and go to state 39
    (               shift and go to state 41
    ID              shift and go to state 43
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47

    args_list                      shift and go to state 35
    expr                           shift and go to state 36
    string                         shift and go to state 37
    term                           shift and go to state 38
    factor                         shift and go to state 40
    elem                           shift and go to state 42
    int                            shift and go to state 44
    float                          shift and go to state 45

state 19

    (24) loop_instruction -> BREAK . ;

    ;               shift and go to state 48


state 20

    (25) loop_instruction -> CONTINUE . ;

    ;               shift and go to state 49


state 21

    (26) return_instruction -> RETURN . expr ;
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float
    (84) int -> . INTNUM
    (85) float -> . FLONUM

    (               shift and go to state 41
    ID              shift and go to state 43
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47

    expr                           shift and go to state 50
    term                           shift and go to state 38
    factor                         shift and go to state 40
    elem                           shift and go to state 42
    int                            shift and go to state 44
    float                          shift and go to state 45

state 22

    (3) instructions_block -> { . instructions }
    (4) instructions -> . instruction instructions
    (5) instructions -> . instruction
    (6) instruction -> . assignment ;
    (7) instruction -> . if_instruction
    (8) instruction -> . for_instruction
    (9) instruction -> . while_instruction
    (10) instruction -> . print_instruction
    (11) instruction -> . loop_instruction
    (12) instruction -> . return_instruction
    (13) instruction -> . instructions_block
    (32) assignment -> . ID = token
    (33) assignment -> . ID ADDASSIGN token
    (34) assignment -> . ID SUBASSIGN token
    (35) assignment -> . ID MULASSIGN token
    (36) assignment -> . ID DIVASSIGN token
    (37) assignment -> . MID = elem
    (14) if_instruction -> . IF ( relational_expr ) instructions_block
    (15) if_instruction -> . IF ( relational_expr ) instruction
    (16) if_instruction -> . IF ( relational_expr ) instructions_block ELSE instruction
    (17) if_instruction -> . IF ( relational_expr ) instruction ELSE instruction
    (18) for_instruction -> . FOR ID = int : ID instructions_block
    (19) for_instruction -> . FOR ID = int : ID instruction
    (20) for_instruction -> . FOR ID = ID : ID instructions_block
    (21) for_instruction -> . FOR ID = ID : ID instruction
    (22) while_instruction -> . WHILE ( relational_expr ) instructions_block
    (23) while_instruction -> . WHILE ( relational_expr ) instruction
    (27) print_instruction -> . PRINT args_list ;
    (24) loop_instruction -> . BREAK ;
    (25) loop_instruction -> . CONTINUE ;
    (26) return_instruction -> . RETURN expr ;
    (3) instructions_block -> . { instructions }
    (59) MID -> . ID [ INTNUM , INTNUM ]

    ID              shift and go to state 13
    IF              shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    PRINT           shift and go to state 18
    BREAK           shift and go to state 19
    CONTINUE        shift and go to state 20
    RETURN          shift and go to state 21
    {               shift and go to state 22

    instructions                   shift and go to state 51
    instruction                    shift and go to state 4
    assignment                     shift and go to state 5
    if_instruction                 shift and go to state 6
    for_instruction                shift and go to state 7
    while_instruction              shift and go to state 8
    print_instruction              shift and go to state 9
    loop_instruction               shift and go to state 10
    return_instruction             shift and go to state 11
    instructions_block             shift and go to state 12
    MID                            shift and go to state 14

state 23

    (4) instructions -> instruction instructions .

    $end            reduce using rule 4 (instructions -> instruction instructions .)
    }               reduce using rule 4 (instructions -> instruction instructions .)


state 24

    (6) instruction -> assignment ; .

    ID              reduce using rule 6 (instruction -> assignment ; .)
    IF              reduce using rule 6 (instruction -> assignment ; .)
    FOR             reduce using rule 6 (instruction -> assignment ; .)
    WHILE           reduce using rule 6 (instruction -> assignment ; .)
    PRINT           reduce using rule 6 (instruction -> assignment ; .)
    BREAK           reduce using rule 6 (instruction -> assignment ; .)
    CONTINUE        reduce using rule 6 (instruction -> assignment ; .)
    RETURN          reduce using rule 6 (instruction -> assignment ; .)
    {               reduce using rule 6 (instruction -> assignment ; .)
    $end            reduce using rule 6 (instruction -> assignment ; .)
    }               reduce using rule 6 (instruction -> assignment ; .)
    ELSE            reduce using rule 6 (instruction -> assignment ; .)


state 25

    (32) assignment -> ID = . token
    (38) token -> . ID
    (39) token -> . int
    (40) token -> . float
    (41) token -> . matrix
    (42) token -> . expr
    (43) token -> . matrix_expr
    (44) token -> . unary_expr
    (84) int -> . INTNUM
    (85) float -> . FLONUM
    (60) matrix -> . [ outerlist ]
    (61) matrix -> . ONES ( args_list )
    (62) matrix -> . ZEROS ( args_list )
    (63) matrix -> . EYE ( args_list )
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (73) matrix_expr -> . matrix_expr DOTADD matrix_term
    (74) matrix_expr -> . matrix_expr DOTSUB matrix_term
    (75) matrix_expr -> . matrix_term
    (82) unary_expr -> . - expr
    (83) unary_expr -> . matrix_expr '
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (76) matrix_term -> . matrix_term DOTMUL matrix_factor
    (77) matrix_term -> . matrix_term DOTDIV matrix_factor
    (78) matrix_term -> . matrix_factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (79) matrix_factor -> . ( matrix_expr )
    (80) matrix_factor -> . matrix
    (81) matrix_factor -> . ID
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float

    ID              shift and go to state 52
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47
    [               shift and go to state 60
    ONES            shift and go to state 61
    ZEROS           shift and go to state 63
    EYE             shift and go to state 64
    -               shift and go to state 65
    (               shift and go to state 62

    token                          shift and go to state 53
    int                            shift and go to state 54
    float                          shift and go to state 55
    matrix                         shift and go to state 56
    expr                           shift and go to state 57
    matrix_expr                    shift and go to state 58
    unary_expr                     shift and go to state 59
    term                           shift and go to state 38
    matrix_term                    shift and go to state 66
    factor                         shift and go to state 40
    matrix_factor                  shift and go to state 67
    elem                           shift and go to state 42

state 26

    (33) assignment -> ID ADDASSIGN . token
    (38) token -> . ID
    (39) token -> . int
    (40) token -> . float
    (41) token -> . matrix
    (42) token -> . expr
    (43) token -> . matrix_expr
    (44) token -> . unary_expr
    (84) int -> . INTNUM
    (85) float -> . FLONUM
    (60) matrix -> . [ outerlist ]
    (61) matrix -> . ONES ( args_list )
    (62) matrix -> . ZEROS ( args_list )
    (63) matrix -> . EYE ( args_list )
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (73) matrix_expr -> . matrix_expr DOTADD matrix_term
    (74) matrix_expr -> . matrix_expr DOTSUB matrix_term
    (75) matrix_expr -> . matrix_term
    (82) unary_expr -> . - expr
    (83) unary_expr -> . matrix_expr '
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (76) matrix_term -> . matrix_term DOTMUL matrix_factor
    (77) matrix_term -> . matrix_term DOTDIV matrix_factor
    (78) matrix_term -> . matrix_factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (79) matrix_factor -> . ( matrix_expr )
    (80) matrix_factor -> . matrix
    (81) matrix_factor -> . ID
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float

    ID              shift and go to state 52
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47
    [               shift and go to state 60
    ONES            shift and go to state 61
    ZEROS           shift and go to state 63
    EYE             shift and go to state 64
    -               shift and go to state 65
    (               shift and go to state 62

    token                          shift and go to state 68
    int                            shift and go to state 54
    float                          shift and go to state 55
    matrix                         shift and go to state 56
    expr                           shift and go to state 57
    matrix_expr                    shift and go to state 58
    unary_expr                     shift and go to state 59
    term                           shift and go to state 38
    matrix_term                    shift and go to state 66
    factor                         shift and go to state 40
    matrix_factor                  shift and go to state 67
    elem                           shift and go to state 42

state 27

    (34) assignment -> ID SUBASSIGN . token
    (38) token -> . ID
    (39) token -> . int
    (40) token -> . float
    (41) token -> . matrix
    (42) token -> . expr
    (43) token -> . matrix_expr
    (44) token -> . unary_expr
    (84) int -> . INTNUM
    (85) float -> . FLONUM
    (60) matrix -> . [ outerlist ]
    (61) matrix -> . ONES ( args_list )
    (62) matrix -> . ZEROS ( args_list )
    (63) matrix -> . EYE ( args_list )
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (73) matrix_expr -> . matrix_expr DOTADD matrix_term
    (74) matrix_expr -> . matrix_expr DOTSUB matrix_term
    (75) matrix_expr -> . matrix_term
    (82) unary_expr -> . - expr
    (83) unary_expr -> . matrix_expr '
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (76) matrix_term -> . matrix_term DOTMUL matrix_factor
    (77) matrix_term -> . matrix_term DOTDIV matrix_factor
    (78) matrix_term -> . matrix_factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (79) matrix_factor -> . ( matrix_expr )
    (80) matrix_factor -> . matrix
    (81) matrix_factor -> . ID
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float

    ID              shift and go to state 52
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47
    [               shift and go to state 60
    ONES            shift and go to state 61
    ZEROS           shift and go to state 63
    EYE             shift and go to state 64
    -               shift and go to state 65
    (               shift and go to state 62

    token                          shift and go to state 69
    int                            shift and go to state 54
    float                          shift and go to state 55
    matrix                         shift and go to state 56
    expr                           shift and go to state 57
    matrix_expr                    shift and go to state 58
    unary_expr                     shift and go to state 59
    term                           shift and go to state 38
    matrix_term                    shift and go to state 66
    factor                         shift and go to state 40
    matrix_factor                  shift and go to state 67
    elem                           shift and go to state 42

state 28

    (35) assignment -> ID MULASSIGN . token
    (38) token -> . ID
    (39) token -> . int
    (40) token -> . float
    (41) token -> . matrix
    (42) token -> . expr
    (43) token -> . matrix_expr
    (44) token -> . unary_expr
    (84) int -> . INTNUM
    (85) float -> . FLONUM
    (60) matrix -> . [ outerlist ]
    (61) matrix -> . ONES ( args_list )
    (62) matrix -> . ZEROS ( args_list )
    (63) matrix -> . EYE ( args_list )
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (73) matrix_expr -> . matrix_expr DOTADD matrix_term
    (74) matrix_expr -> . matrix_expr DOTSUB matrix_term
    (75) matrix_expr -> . matrix_term
    (82) unary_expr -> . - expr
    (83) unary_expr -> . matrix_expr '
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (76) matrix_term -> . matrix_term DOTMUL matrix_factor
    (77) matrix_term -> . matrix_term DOTDIV matrix_factor
    (78) matrix_term -> . matrix_factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (79) matrix_factor -> . ( matrix_expr )
    (80) matrix_factor -> . matrix
    (81) matrix_factor -> . ID
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float

    ID              shift and go to state 52
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47
    [               shift and go to state 60
    ONES            shift and go to state 61
    ZEROS           shift and go to state 63
    EYE             shift and go to state 64
    -               shift and go to state 65
    (               shift and go to state 62

    token                          shift and go to state 70
    int                            shift and go to state 54
    float                          shift and go to state 55
    matrix                         shift and go to state 56
    expr                           shift and go to state 57
    matrix_expr                    shift and go to state 58
    unary_expr                     shift and go to state 59
    term                           shift and go to state 38
    matrix_term                    shift and go to state 66
    factor                         shift and go to state 40
    matrix_factor                  shift and go to state 67
    elem                           shift and go to state 42

state 29

    (36) assignment -> ID DIVASSIGN . token
    (38) token -> . ID
    (39) token -> . int
    (40) token -> . float
    (41) token -> . matrix
    (42) token -> . expr
    (43) token -> . matrix_expr
    (44) token -> . unary_expr
    (84) int -> . INTNUM
    (85) float -> . FLONUM
    (60) matrix -> . [ outerlist ]
    (61) matrix -> . ONES ( args_list )
    (62) matrix -> . ZEROS ( args_list )
    (63) matrix -> . EYE ( args_list )
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (73) matrix_expr -> . matrix_expr DOTADD matrix_term
    (74) matrix_expr -> . matrix_expr DOTSUB matrix_term
    (75) matrix_expr -> . matrix_term
    (82) unary_expr -> . - expr
    (83) unary_expr -> . matrix_expr '
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (76) matrix_term -> . matrix_term DOTMUL matrix_factor
    (77) matrix_term -> . matrix_term DOTDIV matrix_factor
    (78) matrix_term -> . matrix_factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (79) matrix_factor -> . ( matrix_expr )
    (80) matrix_factor -> . matrix
    (81) matrix_factor -> . ID
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float

    ID              shift and go to state 52
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47
    [               shift and go to state 60
    ONES            shift and go to state 61
    ZEROS           shift and go to state 63
    EYE             shift and go to state 64
    -               shift and go to state 65
    (               shift and go to state 62

    token                          shift and go to state 71
    int                            shift and go to state 54
    float                          shift and go to state 55
    matrix                         shift and go to state 56
    expr                           shift and go to state 57
    matrix_expr                    shift and go to state 58
    unary_expr                     shift and go to state 59
    term                           shift and go to state 38
    matrix_term                    shift and go to state 66
    factor                         shift and go to state 40
    matrix_factor                  shift and go to state 67
    elem                           shift and go to state 42

state 30

    (59) MID -> ID [ . INTNUM , INTNUM ]

    INTNUM          shift and go to state 72


state 31

    (37) assignment -> MID = . elem
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float
    (84) int -> . INTNUM
    (85) float -> . FLONUM

    ID              shift and go to state 43
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47

    elem                           shift and go to state 73
    int                            shift and go to state 44
    float                          shift and go to state 45

state 32

    (14) if_instruction -> IF ( . relational_expr ) instructions_block
    (15) if_instruction -> IF ( . relational_expr ) instruction
    (16) if_instruction -> IF ( . relational_expr ) instructions_block ELSE instruction
    (17) if_instruction -> IF ( . relational_expr ) instruction ELSE instruction
    (53) relational_expr -> . expr GREATEREQUAL expr
    (54) relational_expr -> . expr EQUALS expr
    (55) relational_expr -> . expr NOTEQUALS expr
    (56) relational_expr -> . expr LOWEREQUAL expr
    (57) relational_expr -> . expr < expr
    (58) relational_expr -> . expr > expr
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float
    (84) int -> . INTNUM
    (85) float -> . FLONUM

    (               shift and go to state 41
    ID              shift and go to state 43
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47

    relational_expr                shift and go to state 74
    expr                           shift and go to state 75
    term                           shift and go to state 38
    factor                         shift and go to state 40
    elem                           shift and go to state 42
    int                            shift and go to state 44
    float                          shift and go to state 45

state 33

    (18) for_instruction -> FOR ID . = int : ID instructions_block
    (19) for_instruction -> FOR ID . = int : ID instruction
    (20) for_instruction -> FOR ID . = ID : ID instructions_block
    (21) for_instruction -> FOR ID . = ID : ID instruction

    =               shift and go to state 76


state 34

    (22) while_instruction -> WHILE ( . relational_expr ) instructions_block
    (23) while_instruction -> WHILE ( . relational_expr ) instruction
    (53) relational_expr -> . expr GREATEREQUAL expr
    (54) relational_expr -> . expr EQUALS expr
    (55) relational_expr -> . expr NOTEQUALS expr
    (56) relational_expr -> . expr LOWEREQUAL expr
    (57) relational_expr -> . expr < expr
    (58) relational_expr -> . expr > expr
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float
    (84) int -> . INTNUM
    (85) float -> . FLONUM

    (               shift and go to state 41
    ID              shift and go to state 43
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47

    relational_expr                shift and go to state 77
    expr                           shift and go to state 75
    term                           shift and go to state 38
    factor                         shift and go to state 40
    elem                           shift and go to state 42
    int                            shift and go to state 44
    float                          shift and go to state 45

state 35

    (27) print_instruction -> PRINT args_list . ;
    (28) args_list -> args_list . , expr
    (29) args_list -> args_list . , string

    ;               shift and go to state 78
    ,               shift and go to state 79


state 36

    (30) args_list -> expr .
    (45) expr -> expr . + term
    (46) expr -> expr . - term

    ;               reduce using rule 30 (args_list -> expr .)
    ,               reduce using rule 30 (args_list -> expr .)
    )               reduce using rule 30 (args_list -> expr .)
    +               shift and go to state 80
    -               shift and go to state 81


state 37

    (31) args_list -> string .

    ;               reduce using rule 31 (args_list -> string .)
    ,               reduce using rule 31 (args_list -> string .)
    )               reduce using rule 31 (args_list -> string .)


state 38

    (47) expr -> term .
    (48) term -> term . * factor
    (49) term -> term . / factor

    +               reduce using rule 47 (expr -> term .)
    -               reduce using rule 47 (expr -> term .)
    ;               reduce using rule 47 (expr -> term .)
    ,               reduce using rule 47 (expr -> term .)
    GREATEREQUAL    reduce using rule 47 (expr -> term .)
    EQUALS          reduce using rule 47 (expr -> term .)
    NOTEQUALS       reduce using rule 47 (expr -> term .)
    LOWEREQUAL      reduce using rule 47 (expr -> term .)
    <               reduce using rule 47 (expr -> term .)
    >               reduce using rule 47 (expr -> term .)
    )               reduce using rule 47 (expr -> term .)
    *               shift and go to state 82
    /               shift and go to state 83


state 39

    (86) string -> STRING .

    ;               reduce using rule 86 (string -> STRING .)
    ,               reduce using rule 86 (string -> STRING .)
    )               reduce using rule 86 (string -> STRING .)


state 40

    (50) term -> factor .

    *               reduce using rule 50 (term -> factor .)
    /               reduce using rule 50 (term -> factor .)
    +               reduce using rule 50 (term -> factor .)
    -               reduce using rule 50 (term -> factor .)
    ;               reduce using rule 50 (term -> factor .)
    ,               reduce using rule 50 (term -> factor .)
    GREATEREQUAL    reduce using rule 50 (term -> factor .)
    EQUALS          reduce using rule 50 (term -> factor .)
    NOTEQUALS       reduce using rule 50 (term -> factor .)
    LOWEREQUAL      reduce using rule 50 (term -> factor .)
    <               reduce using rule 50 (term -> factor .)
    >               reduce using rule 50 (term -> factor .)
    )               reduce using rule 50 (term -> factor .)


state 41

    (51) factor -> ( . expr )
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float
    (84) int -> . INTNUM
    (85) float -> . FLONUM

    (               shift and go to state 41
    ID              shift and go to state 43
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47

    expr                           shift and go to state 84
    term                           shift and go to state 38
    factor                         shift and go to state 40
    elem                           shift and go to state 42
    int                            shift and go to state 44
    float                          shift and go to state 45

state 42

    (52) factor -> elem .

    *               reduce using rule 52 (factor -> elem .)
    /               reduce using rule 52 (factor -> elem .)
    +               reduce using rule 52 (factor -> elem .)
    -               reduce using rule 52 (factor -> elem .)
    ;               reduce using rule 52 (factor -> elem .)
    ,               reduce using rule 52 (factor -> elem .)
    GREATEREQUAL    reduce using rule 52 (factor -> elem .)
    EQUALS          reduce using rule 52 (factor -> elem .)
    NOTEQUALS       reduce using rule 52 (factor -> elem .)
    LOWEREQUAL      reduce using rule 52 (factor -> elem .)
    <               reduce using rule 52 (factor -> elem .)
    >               reduce using rule 52 (factor -> elem .)
    )               reduce using rule 52 (factor -> elem .)


state 43

    (70) elem -> ID .

    *               reduce using rule 70 (elem -> ID .)
    /               reduce using rule 70 (elem -> ID .)
    +               reduce using rule 70 (elem -> ID .)
    -               reduce using rule 70 (elem -> ID .)
    ;               reduce using rule 70 (elem -> ID .)
    ,               reduce using rule 70 (elem -> ID .)
    GREATEREQUAL    reduce using rule 70 (elem -> ID .)
    EQUALS          reduce using rule 70 (elem -> ID .)
    NOTEQUALS       reduce using rule 70 (elem -> ID .)
    LOWEREQUAL      reduce using rule 70 (elem -> ID .)
    <               reduce using rule 70 (elem -> ID .)
    >               reduce using rule 70 (elem -> ID .)
    )               reduce using rule 70 (elem -> ID .)
    ]               reduce using rule 70 (elem -> ID .)


state 44

    (71) elem -> int .

    *               reduce using rule 71 (elem -> int .)
    /               reduce using rule 71 (elem -> int .)
    +               reduce using rule 71 (elem -> int .)
    -               reduce using rule 71 (elem -> int .)
    ;               reduce using rule 71 (elem -> int .)
    ,               reduce using rule 71 (elem -> int .)
    GREATEREQUAL    reduce using rule 71 (elem -> int .)
    EQUALS          reduce using rule 71 (elem -> int .)
    NOTEQUALS       reduce using rule 71 (elem -> int .)
    LOWEREQUAL      reduce using rule 71 (elem -> int .)
    <               reduce using rule 71 (elem -> int .)
    >               reduce using rule 71 (elem -> int .)
    )               reduce using rule 71 (elem -> int .)
    ]               reduce using rule 71 (elem -> int .)


state 45

    (72) elem -> float .

    *               reduce using rule 72 (elem -> float .)
    /               reduce using rule 72 (elem -> float .)
    +               reduce using rule 72 (elem -> float .)
    -               reduce using rule 72 (elem -> float .)
    ;               reduce using rule 72 (elem -> float .)
    ,               reduce using rule 72 (elem -> float .)
    GREATEREQUAL    reduce using rule 72 (elem -> float .)
    EQUALS          reduce using rule 72 (elem -> float .)
    NOTEQUALS       reduce using rule 72 (elem -> float .)
    LOWEREQUAL      reduce using rule 72 (elem -> float .)
    <               reduce using rule 72 (elem -> float .)
    >               reduce using rule 72 (elem -> float .)
    )               reduce using rule 72 (elem -> float .)
    ]               reduce using rule 72 (elem -> float .)


state 46

    (84) int -> INTNUM .

    *               reduce using rule 84 (int -> INTNUM .)
    /               reduce using rule 84 (int -> INTNUM .)
    +               reduce using rule 84 (int -> INTNUM .)
    -               reduce using rule 84 (int -> INTNUM .)
    ;               reduce using rule 84 (int -> INTNUM .)
    ,               reduce using rule 84 (int -> INTNUM .)
    GREATEREQUAL    reduce using rule 84 (int -> INTNUM .)
    EQUALS          reduce using rule 84 (int -> INTNUM .)
    NOTEQUALS       reduce using rule 84 (int -> INTNUM .)
    LOWEREQUAL      reduce using rule 84 (int -> INTNUM .)
    <               reduce using rule 84 (int -> INTNUM .)
    >               reduce using rule 84 (int -> INTNUM .)
    )               reduce using rule 84 (int -> INTNUM .)
    ]               reduce using rule 84 (int -> INTNUM .)
    :               reduce using rule 84 (int -> INTNUM .)


state 47

    (85) float -> FLONUM .

    *               reduce using rule 85 (float -> FLONUM .)
    /               reduce using rule 85 (float -> FLONUM .)
    +               reduce using rule 85 (float -> FLONUM .)
    -               reduce using rule 85 (float -> FLONUM .)
    ;               reduce using rule 85 (float -> FLONUM .)
    ,               reduce using rule 85 (float -> FLONUM .)
    GREATEREQUAL    reduce using rule 85 (float -> FLONUM .)
    EQUALS          reduce using rule 85 (float -> FLONUM .)
    NOTEQUALS       reduce using rule 85 (float -> FLONUM .)
    LOWEREQUAL      reduce using rule 85 (float -> FLONUM .)
    <               reduce using rule 85 (float -> FLONUM .)
    >               reduce using rule 85 (float -> FLONUM .)
    )               reduce using rule 85 (float -> FLONUM .)
    ]               reduce using rule 85 (float -> FLONUM .)


state 48

    (24) loop_instruction -> BREAK ; .

    ID              reduce using rule 24 (loop_instruction -> BREAK ; .)
    IF              reduce using rule 24 (loop_instruction -> BREAK ; .)
    FOR             reduce using rule 24 (loop_instruction -> BREAK ; .)
    WHILE           reduce using rule 24 (loop_instruction -> BREAK ; .)
    PRINT           reduce using rule 24 (loop_instruction -> BREAK ; .)
    BREAK           reduce using rule 24 (loop_instruction -> BREAK ; .)
    CONTINUE        reduce using rule 24 (loop_instruction -> BREAK ; .)
    RETURN          reduce using rule 24 (loop_instruction -> BREAK ; .)
    {               reduce using rule 24 (loop_instruction -> BREAK ; .)
    $end            reduce using rule 24 (loop_instruction -> BREAK ; .)
    }               reduce using rule 24 (loop_instruction -> BREAK ; .)
    ELSE            reduce using rule 24 (loop_instruction -> BREAK ; .)


state 49

    (25) loop_instruction -> CONTINUE ; .

    ID              reduce using rule 25 (loop_instruction -> CONTINUE ; .)
    IF              reduce using rule 25 (loop_instruction -> CONTINUE ; .)
    FOR             reduce using rule 25 (loop_instruction -> CONTINUE ; .)
    WHILE           reduce using rule 25 (loop_instruction -> CONTINUE ; .)
    PRINT           reduce using rule 25 (loop_instruction -> CONTINUE ; .)
    BREAK           reduce using rule 25 (loop_instruction -> CONTINUE ; .)
    CONTINUE        reduce using rule 25 (loop_instruction -> CONTINUE ; .)
    RETURN          reduce using rule 25 (loop_instruction -> CONTINUE ; .)
    {               reduce using rule 25 (loop_instruction -> CONTINUE ; .)
    $end            reduce using rule 25 (loop_instruction -> CONTINUE ; .)
    }               reduce using rule 25 (loop_instruction -> CONTINUE ; .)
    ELSE            reduce using rule 25 (loop_instruction -> CONTINUE ; .)


state 50

    (26) return_instruction -> RETURN expr . ;
    (45) expr -> expr . + term
    (46) expr -> expr . - term

    ;               shift and go to state 85
    +               shift and go to state 80
    -               shift and go to state 81


state 51

    (3) instructions_block -> { instructions . }

    }               shift and go to state 86


state 52

    (38) token -> ID .
    (81) matrix_factor -> ID .
    (70) elem -> ID .

  ! reduce/reduce conflict for ; resolved using rule 38 (token -> ID .)
  ! reduce/reduce conflict for ; resolved using rule 38 (token -> ID .)
    ;               reduce using rule 38 (token -> ID .)
    DOTMUL          reduce using rule 81 (matrix_factor -> ID .)
    DOTDIV          reduce using rule 81 (matrix_factor -> ID .)
    DOTADD          reduce using rule 81 (matrix_factor -> ID .)
    DOTSUB          reduce using rule 81 (matrix_factor -> ID .)
    '               reduce using rule 81 (matrix_factor -> ID .)
    *               reduce using rule 70 (elem -> ID .)
    /               reduce using rule 70 (elem -> ID .)
    +               reduce using rule 70 (elem -> ID .)
    -               reduce using rule 70 (elem -> ID .)

  ! ;               [ reduce using rule 81 (matrix_factor -> ID .) ]
  ! ;               [ reduce using rule 70 (elem -> ID .) ]


state 53

    (32) assignment -> ID = token .

    ;               reduce using rule 32 (assignment -> ID = token .)


state 54

    (39) token -> int .
    (71) elem -> int .

  ! reduce/reduce conflict for ; resolved using rule 39 (token -> int .)
    ;               reduce using rule 39 (token -> int .)
    *               reduce using rule 71 (elem -> int .)
    /               reduce using rule 71 (elem -> int .)
    +               reduce using rule 71 (elem -> int .)
    -               reduce using rule 71 (elem -> int .)

  ! ;               [ reduce using rule 71 (elem -> int .) ]


state 55

    (40) token -> float .
    (72) elem -> float .

  ! reduce/reduce conflict for ; resolved using rule 40 (token -> float .)
    ;               reduce using rule 40 (token -> float .)
    *               reduce using rule 72 (elem -> float .)
    /               reduce using rule 72 (elem -> float .)
    +               reduce using rule 72 (elem -> float .)
    -               reduce using rule 72 (elem -> float .)

  ! ;               [ reduce using rule 72 (elem -> float .) ]


state 56

    (41) token -> matrix .
    (80) matrix_factor -> matrix .

  ! reduce/reduce conflict for ; resolved using rule 41 (token -> matrix .)
    ;               reduce using rule 41 (token -> matrix .)
    DOTMUL          reduce using rule 80 (matrix_factor -> matrix .)
    DOTDIV          reduce using rule 80 (matrix_factor -> matrix .)
    DOTADD          reduce using rule 80 (matrix_factor -> matrix .)
    DOTSUB          reduce using rule 80 (matrix_factor -> matrix .)
    '               reduce using rule 80 (matrix_factor -> matrix .)

  ! ;               [ reduce using rule 80 (matrix_factor -> matrix .) ]


state 57

    (42) token -> expr .
    (45) expr -> expr . + term
    (46) expr -> expr . - term

    ;               reduce using rule 42 (token -> expr .)
    +               shift and go to state 80
    -               shift and go to state 81


state 58

    (43) token -> matrix_expr .
    (73) matrix_expr -> matrix_expr . DOTADD matrix_term
    (74) matrix_expr -> matrix_expr . DOTSUB matrix_term
    (83) unary_expr -> matrix_expr . '

    ;               reduce using rule 43 (token -> matrix_expr .)
    DOTADD          shift and go to state 87
    DOTSUB          shift and go to state 88
    '               shift and go to state 89


state 59

    (44) token -> unary_expr .

    ;               reduce using rule 44 (token -> unary_expr .)


state 60

    (60) matrix -> [ . outerlist ]
    (65) outerlist -> . outerlist ; innerlist
    (66) outerlist -> . innerlist
    (67) innerlist -> . innerlist , elem
    (68) innerlist -> . elem
    (69) innerlist -> .
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float
    (84) int -> . INTNUM
    (85) float -> . FLONUM

    ,               reduce using rule 69 (innerlist -> .)
    ]               reduce using rule 69 (innerlist -> .)
    ;               reduce using rule 69 (innerlist -> .)
    ID              shift and go to state 43
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47

    outerlist                      shift and go to state 90
    innerlist                      shift and go to state 91
    elem                           shift and go to state 92
    int                            shift and go to state 44
    float                          shift and go to state 45

state 61

    (61) matrix -> ONES . ( args_list )

    (               shift and go to state 93


state 62

    (51) factor -> ( . expr )
    (79) matrix_factor -> ( . matrix_expr )
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (73) matrix_expr -> . matrix_expr DOTADD matrix_term
    (74) matrix_expr -> . matrix_expr DOTSUB matrix_term
    (75) matrix_expr -> . matrix_term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (76) matrix_term -> . matrix_term DOTMUL matrix_factor
    (77) matrix_term -> . matrix_term DOTDIV matrix_factor
    (78) matrix_term -> . matrix_factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (79) matrix_factor -> . ( matrix_expr )
    (80) matrix_factor -> . matrix
    (81) matrix_factor -> . ID
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float
    (60) matrix -> . [ outerlist ]
    (61) matrix -> . ONES ( args_list )
    (62) matrix -> . ZEROS ( args_list )
    (63) matrix -> . EYE ( args_list )
    (84) int -> . INTNUM
    (85) float -> . FLONUM

    (               shift and go to state 62
    ID              shift and go to state 96
    [               shift and go to state 60
    ONES            shift and go to state 61
    ZEROS           shift and go to state 63
    EYE             shift and go to state 64
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47

    expr                           shift and go to state 84
    matrix_expr                    shift and go to state 94
    term                           shift and go to state 38
    matrix_term                    shift and go to state 66
    factor                         shift and go to state 40
    matrix_factor                  shift and go to state 67
    elem                           shift and go to state 42
    matrix                         shift and go to state 95
    int                            shift and go to state 44
    float                          shift and go to state 45

state 63

    (62) matrix -> ZEROS . ( args_list )

    (               shift and go to state 97


state 64

    (63) matrix -> EYE . ( args_list )

    (               shift and go to state 98


state 65

    (82) unary_expr -> - . expr
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float
    (84) int -> . INTNUM
    (85) float -> . FLONUM

    (               shift and go to state 41
    ID              shift and go to state 43
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47

    expr                           shift and go to state 99
    term                           shift and go to state 38
    factor                         shift and go to state 40
    elem                           shift and go to state 42
    int                            shift and go to state 44
    float                          shift and go to state 45

state 66

    (75) matrix_expr -> matrix_term .
    (76) matrix_term -> matrix_term . DOTMUL matrix_factor
    (77) matrix_term -> matrix_term . DOTDIV matrix_factor

    DOTADD          reduce using rule 75 (matrix_expr -> matrix_term .)
    DOTSUB          reduce using rule 75 (matrix_expr -> matrix_term .)
    '               reduce using rule 75 (matrix_expr -> matrix_term .)
    ;               reduce using rule 75 (matrix_expr -> matrix_term .)
    )               reduce using rule 75 (matrix_expr -> matrix_term .)
    DOTMUL          shift and go to state 100
    DOTDIV          shift and go to state 101


state 67

    (78) matrix_term -> matrix_factor .

    DOTMUL          reduce using rule 78 (matrix_term -> matrix_factor .)
    DOTDIV          reduce using rule 78 (matrix_term -> matrix_factor .)
    DOTADD          reduce using rule 78 (matrix_term -> matrix_factor .)
    DOTSUB          reduce using rule 78 (matrix_term -> matrix_factor .)
    '               reduce using rule 78 (matrix_term -> matrix_factor .)
    ;               reduce using rule 78 (matrix_term -> matrix_factor .)
    )               reduce using rule 78 (matrix_term -> matrix_factor .)


state 68

    (33) assignment -> ID ADDASSIGN token .

    ;               reduce using rule 33 (assignment -> ID ADDASSIGN token .)


state 69

    (34) assignment -> ID SUBASSIGN token .

    ;               reduce using rule 34 (assignment -> ID SUBASSIGN token .)


state 70

    (35) assignment -> ID MULASSIGN token .

    ;               reduce using rule 35 (assignment -> ID MULASSIGN token .)


state 71

    (36) assignment -> ID DIVASSIGN token .

    ;               reduce using rule 36 (assignment -> ID DIVASSIGN token .)


state 72

    (59) MID -> ID [ INTNUM . , INTNUM ]

    ,               shift and go to state 102


state 73

    (37) assignment -> MID = elem .

    ;               reduce using rule 37 (assignment -> MID = elem .)


state 74

    (14) if_instruction -> IF ( relational_expr . ) instructions_block
    (15) if_instruction -> IF ( relational_expr . ) instruction
    (16) if_instruction -> IF ( relational_expr . ) instructions_block ELSE instruction
    (17) if_instruction -> IF ( relational_expr . ) instruction ELSE instruction

    )               shift and go to state 103


state 75

    (53) relational_expr -> expr . GREATEREQUAL expr
    (54) relational_expr -> expr . EQUALS expr
    (55) relational_expr -> expr . NOTEQUALS expr
    (56) relational_expr -> expr . LOWEREQUAL expr
    (57) relational_expr -> expr . < expr
    (58) relational_expr -> expr . > expr
    (45) expr -> expr . + term
    (46) expr -> expr . - term

    GREATEREQUAL    shift and go to state 104
    EQUALS          shift and go to state 105
    NOTEQUALS       shift and go to state 106
    LOWEREQUAL      shift and go to state 107
    <               shift and go to state 108
    >               shift and go to state 109
    +               shift and go to state 80
    -               shift and go to state 81


state 76

    (18) for_instruction -> FOR ID = . int : ID instructions_block
    (19) for_instruction -> FOR ID = . int : ID instruction
    (20) for_instruction -> FOR ID = . ID : ID instructions_block
    (21) for_instruction -> FOR ID = . ID : ID instruction
    (84) int -> . INTNUM

    ID              shift and go to state 110
    INTNUM          shift and go to state 46

    int                            shift and go to state 111

state 77

    (22) while_instruction -> WHILE ( relational_expr . ) instructions_block
    (23) while_instruction -> WHILE ( relational_expr . ) instruction

    )               shift and go to state 112


state 78

    (27) print_instruction -> PRINT args_list ; .

    ID              reduce using rule 27 (print_instruction -> PRINT args_list ; .)
    IF              reduce using rule 27 (print_instruction -> PRINT args_list ; .)
    FOR             reduce using rule 27 (print_instruction -> PRINT args_list ; .)
    WHILE           reduce using rule 27 (print_instruction -> PRINT args_list ; .)
    PRINT           reduce using rule 27 (print_instruction -> PRINT args_list ; .)
    BREAK           reduce using rule 27 (print_instruction -> PRINT args_list ; .)
    CONTINUE        reduce using rule 27 (print_instruction -> PRINT args_list ; .)
    RETURN          reduce using rule 27 (print_instruction -> PRINT args_list ; .)
    {               reduce using rule 27 (print_instruction -> PRINT args_list ; .)
    $end            reduce using rule 27 (print_instruction -> PRINT args_list ; .)
    }               reduce using rule 27 (print_instruction -> PRINT args_list ; .)
    ELSE            reduce using rule 27 (print_instruction -> PRINT args_list ; .)


state 79

    (28) args_list -> args_list , . expr
    (29) args_list -> args_list , . string
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (86) string -> . STRING
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float
    (84) int -> . INTNUM
    (85) float -> . FLONUM

    STRING          shift and go to state 39
    (               shift and go to state 41
    ID              shift and go to state 43
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47

    expr                           shift and go to state 113
    string                         shift and go to state 114
    term                           shift and go to state 38
    factor                         shift and go to state 40
    elem                           shift and go to state 42
    int                            shift and go to state 44
    float                          shift and go to state 45

state 80

    (45) expr -> expr + . term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float
    (84) int -> . INTNUM
    (85) float -> . FLONUM

    (               shift and go to state 41
    ID              shift and go to state 43
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47

    term                           shift and go to state 115
    factor                         shift and go to state 40
    elem                           shift and go to state 42
    int                            shift and go to state 44
    float                          shift and go to state 45

state 81

    (46) expr -> expr - . term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float
    (84) int -> . INTNUM
    (85) float -> . FLONUM

    (               shift and go to state 41
    ID              shift and go to state 43
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47

    term                           shift and go to state 116
    factor                         shift and go to state 40
    elem                           shift and go to state 42
    int                            shift and go to state 44
    float                          shift and go to state 45

state 82

    (48) term -> term * . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float
    (84) int -> . INTNUM
    (85) float -> . FLONUM

    (               shift and go to state 41
    ID              shift and go to state 43
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47

    factor                         shift and go to state 117
    elem                           shift and go to state 42
    int                            shift and go to state 44
    float                          shift and go to state 45

state 83

    (49) term -> term / . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float
    (84) int -> . INTNUM
    (85) float -> . FLONUM

    (               shift and go to state 41
    ID              shift and go to state 43
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47

    factor                         shift and go to state 118
    elem                           shift and go to state 42
    int                            shift and go to state 44
    float                          shift and go to state 45

state 84

    (51) factor -> ( expr . )
    (45) expr -> expr . + term
    (46) expr -> expr . - term

    )               shift and go to state 119
    +               shift and go to state 80
    -               shift and go to state 81


state 85

    (26) return_instruction -> RETURN expr ; .

    ID              reduce using rule 26 (return_instruction -> RETURN expr ; .)
    IF              reduce using rule 26 (return_instruction -> RETURN expr ; .)
    FOR             reduce using rule 26 (return_instruction -> RETURN expr ; .)
    WHILE           reduce using rule 26 (return_instruction -> RETURN expr ; .)
    PRINT           reduce using rule 26 (return_instruction -> RETURN expr ; .)
    BREAK           reduce using rule 26 (return_instruction -> RETURN expr ; .)
    CONTINUE        reduce using rule 26 (return_instruction -> RETURN expr ; .)
    RETURN          reduce using rule 26 (return_instruction -> RETURN expr ; .)
    {               reduce using rule 26 (return_instruction -> RETURN expr ; .)
    $end            reduce using rule 26 (return_instruction -> RETURN expr ; .)
    }               reduce using rule 26 (return_instruction -> RETURN expr ; .)
    ELSE            reduce using rule 26 (return_instruction -> RETURN expr ; .)


state 86

    (3) instructions_block -> { instructions } .

    ID              reduce using rule 3 (instructions_block -> { instructions } .)
    IF              reduce using rule 3 (instructions_block -> { instructions } .)
    FOR             reduce using rule 3 (instructions_block -> { instructions } .)
    WHILE           reduce using rule 3 (instructions_block -> { instructions } .)
    PRINT           reduce using rule 3 (instructions_block -> { instructions } .)
    BREAK           reduce using rule 3 (instructions_block -> { instructions } .)
    CONTINUE        reduce using rule 3 (instructions_block -> { instructions } .)
    RETURN          reduce using rule 3 (instructions_block -> { instructions } .)
    {               reduce using rule 3 (instructions_block -> { instructions } .)
    $end            reduce using rule 3 (instructions_block -> { instructions } .)
    }               reduce using rule 3 (instructions_block -> { instructions } .)
    ELSE            reduce using rule 3 (instructions_block -> { instructions } .)


state 87

    (73) matrix_expr -> matrix_expr DOTADD . matrix_term
    (76) matrix_term -> . matrix_term DOTMUL matrix_factor
    (77) matrix_term -> . matrix_term DOTDIV matrix_factor
    (78) matrix_term -> . matrix_factor
    (79) matrix_factor -> . ( matrix_expr )
    (80) matrix_factor -> . matrix
    (81) matrix_factor -> . ID
    (60) matrix -> . [ outerlist ]
    (61) matrix -> . ONES ( args_list )
    (62) matrix -> . ZEROS ( args_list )
    (63) matrix -> . EYE ( args_list )

    (               shift and go to state 121
    ID              shift and go to state 122
    [               shift and go to state 60
    ONES            shift and go to state 61
    ZEROS           shift and go to state 63
    EYE             shift and go to state 64

    matrix_term                    shift and go to state 120
    matrix_factor                  shift and go to state 67
    matrix                         shift and go to state 95

state 88

    (74) matrix_expr -> matrix_expr DOTSUB . matrix_term
    (76) matrix_term -> . matrix_term DOTMUL matrix_factor
    (77) matrix_term -> . matrix_term DOTDIV matrix_factor
    (78) matrix_term -> . matrix_factor
    (79) matrix_factor -> . ( matrix_expr )
    (80) matrix_factor -> . matrix
    (81) matrix_factor -> . ID
    (60) matrix -> . [ outerlist ]
    (61) matrix -> . ONES ( args_list )
    (62) matrix -> . ZEROS ( args_list )
    (63) matrix -> . EYE ( args_list )

    (               shift and go to state 121
    ID              shift and go to state 122
    [               shift and go to state 60
    ONES            shift and go to state 61
    ZEROS           shift and go to state 63
    EYE             shift and go to state 64

    matrix_term                    shift and go to state 123
    matrix_factor                  shift and go to state 67
    matrix                         shift and go to state 95

state 89

    (83) unary_expr -> matrix_expr ' .

    ;               reduce using rule 83 (unary_expr -> matrix_expr ' .)


state 90

    (60) matrix -> [ outerlist . ]
    (65) outerlist -> outerlist . ; innerlist

    ]               shift and go to state 124
    ;               shift and go to state 125


state 91

    (66) outerlist -> innerlist .
    (67) innerlist -> innerlist . , elem

    ]               reduce using rule 66 (outerlist -> innerlist .)
    ;               reduce using rule 66 (outerlist -> innerlist .)
    ,               shift and go to state 126


state 92

    (68) innerlist -> elem .

    ,               reduce using rule 68 (innerlist -> elem .)
    ]               reduce using rule 68 (innerlist -> elem .)
    ;               reduce using rule 68 (innerlist -> elem .)


state 93

    (61) matrix -> ONES ( . args_list )
    (28) args_list -> . args_list , expr
    (29) args_list -> . args_list , string
    (30) args_list -> . expr
    (31) args_list -> . string
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (86) string -> . STRING
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float
    (84) int -> . INTNUM
    (85) float -> . FLONUM

    STRING          shift and go to state 39
    (               shift and go to state 41
    ID              shift and go to state 43
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47

    args_list                      shift and go to state 127
    expr                           shift and go to state 36
    string                         shift and go to state 37
    term                           shift and go to state 38
    factor                         shift and go to state 40
    elem                           shift and go to state 42
    int                            shift and go to state 44
    float                          shift and go to state 45

state 94

    (79) matrix_factor -> ( matrix_expr . )
    (73) matrix_expr -> matrix_expr . DOTADD matrix_term
    (74) matrix_expr -> matrix_expr . DOTSUB matrix_term

    )               shift and go to state 128
    DOTADD          shift and go to state 87
    DOTSUB          shift and go to state 88


state 95

    (80) matrix_factor -> matrix .

    DOTMUL          reduce using rule 80 (matrix_factor -> matrix .)
    DOTDIV          reduce using rule 80 (matrix_factor -> matrix .)
    )               reduce using rule 80 (matrix_factor -> matrix .)
    DOTADD          reduce using rule 80 (matrix_factor -> matrix .)
    DOTSUB          reduce using rule 80 (matrix_factor -> matrix .)
    '               reduce using rule 80 (matrix_factor -> matrix .)
    ;               reduce using rule 80 (matrix_factor -> matrix .)


state 96

    (81) matrix_factor -> ID .
    (70) elem -> ID .

  ! reduce/reduce conflict for ) resolved using rule 70 (elem -> ID .)
    DOTMUL          reduce using rule 81 (matrix_factor -> ID .)
    DOTDIV          reduce using rule 81 (matrix_factor -> ID .)
    DOTADD          reduce using rule 81 (matrix_factor -> ID .)
    DOTSUB          reduce using rule 81 (matrix_factor -> ID .)
    *               reduce using rule 70 (elem -> ID .)
    /               reduce using rule 70 (elem -> ID .)
    )               reduce using rule 70 (elem -> ID .)
    +               reduce using rule 70 (elem -> ID .)
    -               reduce using rule 70 (elem -> ID .)

  ! )               [ reduce using rule 81 (matrix_factor -> ID .) ]


state 97

    (62) matrix -> ZEROS ( . args_list )
    (28) args_list -> . args_list , expr
    (29) args_list -> . args_list , string
    (30) args_list -> . expr
    (31) args_list -> . string
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (86) string -> . STRING
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float
    (84) int -> . INTNUM
    (85) float -> . FLONUM

    STRING          shift and go to state 39
    (               shift and go to state 41
    ID              shift and go to state 43
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47

    args_list                      shift and go to state 129
    expr                           shift and go to state 36
    string                         shift and go to state 37
    term                           shift and go to state 38
    factor                         shift and go to state 40
    elem                           shift and go to state 42
    int                            shift and go to state 44
    float                          shift and go to state 45

state 98

    (63) matrix -> EYE ( . args_list )
    (28) args_list -> . args_list , expr
    (29) args_list -> . args_list , string
    (30) args_list -> . expr
    (31) args_list -> . string
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (86) string -> . STRING
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float
    (84) int -> . INTNUM
    (85) float -> . FLONUM

    STRING          shift and go to state 39
    (               shift and go to state 41
    ID              shift and go to state 43
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47

    args_list                      shift and go to state 130
    expr                           shift and go to state 36
    string                         shift and go to state 37
    term                           shift and go to state 38
    factor                         shift and go to state 40
    elem                           shift and go to state 42
    int                            shift and go to state 44
    float                          shift and go to state 45

state 99

    (82) unary_expr -> - expr .
    (45) expr -> expr . + term
    (46) expr -> expr . - term

    ;               reduce using rule 82 (unary_expr -> - expr .)
    +               shift and go to state 80
    -               shift and go to state 81


state 100

    (76) matrix_term -> matrix_term DOTMUL . matrix_factor
    (79) matrix_factor -> . ( matrix_expr )
    (80) matrix_factor -> . matrix
    (81) matrix_factor -> . ID
    (60) matrix -> . [ outerlist ]
    (61) matrix -> . ONES ( args_list )
    (62) matrix -> . ZEROS ( args_list )
    (63) matrix -> . EYE ( args_list )

    (               shift and go to state 121
    ID              shift and go to state 122
    [               shift and go to state 60
    ONES            shift and go to state 61
    ZEROS           shift and go to state 63
    EYE             shift and go to state 64

    matrix_factor                  shift and go to state 131
    matrix                         shift and go to state 95

state 101

    (77) matrix_term -> matrix_term DOTDIV . matrix_factor
    (79) matrix_factor -> . ( matrix_expr )
    (80) matrix_factor -> . matrix
    (81) matrix_factor -> . ID
    (60) matrix -> . [ outerlist ]
    (61) matrix -> . ONES ( args_list )
    (62) matrix -> . ZEROS ( args_list )
    (63) matrix -> . EYE ( args_list )

    (               shift and go to state 121
    ID              shift and go to state 122
    [               shift and go to state 60
    ONES            shift and go to state 61
    ZEROS           shift and go to state 63
    EYE             shift and go to state 64

    matrix_factor                  shift and go to state 132
    matrix                         shift and go to state 95

state 102

    (59) MID -> ID [ INTNUM , . INTNUM ]

    INTNUM          shift and go to state 133


state 103

    (14) if_instruction -> IF ( relational_expr ) . instructions_block
    (15) if_instruction -> IF ( relational_expr ) . instruction
    (16) if_instruction -> IF ( relational_expr ) . instructions_block ELSE instruction
    (17) if_instruction -> IF ( relational_expr ) . instruction ELSE instruction
    (3) instructions_block -> . { instructions }
    (6) instruction -> . assignment ;
    (7) instruction -> . if_instruction
    (8) instruction -> . for_instruction
    (9) instruction -> . while_instruction
    (10) instruction -> . print_instruction
    (11) instruction -> . loop_instruction
    (12) instruction -> . return_instruction
    (13) instruction -> . instructions_block
    (32) assignment -> . ID = token
    (33) assignment -> . ID ADDASSIGN token
    (34) assignment -> . ID SUBASSIGN token
    (35) assignment -> . ID MULASSIGN token
    (36) assignment -> . ID DIVASSIGN token
    (37) assignment -> . MID = elem
    (14) if_instruction -> . IF ( relational_expr ) instructions_block
    (15) if_instruction -> . IF ( relational_expr ) instruction
    (16) if_instruction -> . IF ( relational_expr ) instructions_block ELSE instruction
    (17) if_instruction -> . IF ( relational_expr ) instruction ELSE instruction
    (18) for_instruction -> . FOR ID = int : ID instructions_block
    (19) for_instruction -> . FOR ID = int : ID instruction
    (20) for_instruction -> . FOR ID = ID : ID instructions_block
    (21) for_instruction -> . FOR ID = ID : ID instruction
    (22) while_instruction -> . WHILE ( relational_expr ) instructions_block
    (23) while_instruction -> . WHILE ( relational_expr ) instruction
    (27) print_instruction -> . PRINT args_list ;
    (24) loop_instruction -> . BREAK ;
    (25) loop_instruction -> . CONTINUE ;
    (26) return_instruction -> . RETURN expr ;
    (59) MID -> . ID [ INTNUM , INTNUM ]

    {               shift and go to state 22
    ID              shift and go to state 13
    IF              shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    PRINT           shift and go to state 18
    BREAK           shift and go to state 19
    CONTINUE        shift and go to state 20
    RETURN          shift and go to state 21

    instructions_block             shift and go to state 134
    instruction                    shift and go to state 135
    assignment                     shift and go to state 5
    if_instruction                 shift and go to state 6
    for_instruction                shift and go to state 7
    while_instruction              shift and go to state 8
    print_instruction              shift and go to state 9
    loop_instruction               shift and go to state 10
    return_instruction             shift and go to state 11
    MID                            shift and go to state 14

state 104

    (53) relational_expr -> expr GREATEREQUAL . expr
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float
    (84) int -> . INTNUM
    (85) float -> . FLONUM

    (               shift and go to state 41
    ID              shift and go to state 43
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47

    expr                           shift and go to state 136
    term                           shift and go to state 38
    factor                         shift and go to state 40
    elem                           shift and go to state 42
    int                            shift and go to state 44
    float                          shift and go to state 45

state 105

    (54) relational_expr -> expr EQUALS . expr
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float
    (84) int -> . INTNUM
    (85) float -> . FLONUM

    (               shift and go to state 41
    ID              shift and go to state 43
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47

    expr                           shift and go to state 137
    term                           shift and go to state 38
    factor                         shift and go to state 40
    elem                           shift and go to state 42
    int                            shift and go to state 44
    float                          shift and go to state 45

state 106

    (55) relational_expr -> expr NOTEQUALS . expr
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float
    (84) int -> . INTNUM
    (85) float -> . FLONUM

    (               shift and go to state 41
    ID              shift and go to state 43
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47

    expr                           shift and go to state 138
    term                           shift and go to state 38
    factor                         shift and go to state 40
    elem                           shift and go to state 42
    int                            shift and go to state 44
    float                          shift and go to state 45

state 107

    (56) relational_expr -> expr LOWEREQUAL . expr
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float
    (84) int -> . INTNUM
    (85) float -> . FLONUM

    (               shift and go to state 41
    ID              shift and go to state 43
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47

    expr                           shift and go to state 139
    term                           shift and go to state 38
    factor                         shift and go to state 40
    elem                           shift and go to state 42
    int                            shift and go to state 44
    float                          shift and go to state 45

state 108

    (57) relational_expr -> expr < . expr
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float
    (84) int -> . INTNUM
    (85) float -> . FLONUM

    (               shift and go to state 41
    ID              shift and go to state 43
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47

    expr                           shift and go to state 140
    term                           shift and go to state 38
    factor                         shift and go to state 40
    elem                           shift and go to state 42
    int                            shift and go to state 44
    float                          shift and go to state 45

state 109

    (58) relational_expr -> expr > . expr
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float
    (84) int -> . INTNUM
    (85) float -> . FLONUM

    (               shift and go to state 41
    ID              shift and go to state 43
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47

    expr                           shift and go to state 141
    term                           shift and go to state 38
    factor                         shift and go to state 40
    elem                           shift and go to state 42
    int                            shift and go to state 44
    float                          shift and go to state 45

state 110

    (20) for_instruction -> FOR ID = ID . : ID instructions_block
    (21) for_instruction -> FOR ID = ID . : ID instruction

    :               shift and go to state 142


state 111

    (18) for_instruction -> FOR ID = int . : ID instructions_block
    (19) for_instruction -> FOR ID = int . : ID instruction

    :               shift and go to state 143


state 112

    (22) while_instruction -> WHILE ( relational_expr ) . instructions_block
    (23) while_instruction -> WHILE ( relational_expr ) . instruction
    (3) instructions_block -> . { instructions }
    (6) instruction -> . assignment ;
    (7) instruction -> . if_instruction
    (8) instruction -> . for_instruction
    (9) instruction -> . while_instruction
    (10) instruction -> . print_instruction
    (11) instruction -> . loop_instruction
    (12) instruction -> . return_instruction
    (13) instruction -> . instructions_block
    (32) assignment -> . ID = token
    (33) assignment -> . ID ADDASSIGN token
    (34) assignment -> . ID SUBASSIGN token
    (35) assignment -> . ID MULASSIGN token
    (36) assignment -> . ID DIVASSIGN token
    (37) assignment -> . MID = elem
    (14) if_instruction -> . IF ( relational_expr ) instructions_block
    (15) if_instruction -> . IF ( relational_expr ) instruction
    (16) if_instruction -> . IF ( relational_expr ) instructions_block ELSE instruction
    (17) if_instruction -> . IF ( relational_expr ) instruction ELSE instruction
    (18) for_instruction -> . FOR ID = int : ID instructions_block
    (19) for_instruction -> . FOR ID = int : ID instruction
    (20) for_instruction -> . FOR ID = ID : ID instructions_block
    (21) for_instruction -> . FOR ID = ID : ID instruction
    (22) while_instruction -> . WHILE ( relational_expr ) instructions_block
    (23) while_instruction -> . WHILE ( relational_expr ) instruction
    (27) print_instruction -> . PRINT args_list ;
    (24) loop_instruction -> . BREAK ;
    (25) loop_instruction -> . CONTINUE ;
    (26) return_instruction -> . RETURN expr ;
    (59) MID -> . ID [ INTNUM , INTNUM ]

    {               shift and go to state 22
    ID              shift and go to state 13
    IF              shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    PRINT           shift and go to state 18
    BREAK           shift and go to state 19
    CONTINUE        shift and go to state 20
    RETURN          shift and go to state 21

    instructions_block             shift and go to state 144
    instruction                    shift and go to state 145
    assignment                     shift and go to state 5
    if_instruction                 shift and go to state 6
    for_instruction                shift and go to state 7
    while_instruction              shift and go to state 8
    print_instruction              shift and go to state 9
    loop_instruction               shift and go to state 10
    return_instruction             shift and go to state 11
    MID                            shift and go to state 14

state 113

    (28) args_list -> args_list , expr .
    (45) expr -> expr . + term
    (46) expr -> expr . - term

    ;               reduce using rule 28 (args_list -> args_list , expr .)
    ,               reduce using rule 28 (args_list -> args_list , expr .)
    )               reduce using rule 28 (args_list -> args_list , expr .)
    +               shift and go to state 80
    -               shift and go to state 81


state 114

    (29) args_list -> args_list , string .

    ;               reduce using rule 29 (args_list -> args_list , string .)
    ,               reduce using rule 29 (args_list -> args_list , string .)
    )               reduce using rule 29 (args_list -> args_list , string .)


state 115

    (45) expr -> expr + term .
    (48) term -> term . * factor
    (49) term -> term . / factor

    +               reduce using rule 45 (expr -> expr + term .)
    -               reduce using rule 45 (expr -> expr + term .)
    ;               reduce using rule 45 (expr -> expr + term .)
    ,               reduce using rule 45 (expr -> expr + term .)
    GREATEREQUAL    reduce using rule 45 (expr -> expr + term .)
    EQUALS          reduce using rule 45 (expr -> expr + term .)
    NOTEQUALS       reduce using rule 45 (expr -> expr + term .)
    LOWEREQUAL      reduce using rule 45 (expr -> expr + term .)
    <               reduce using rule 45 (expr -> expr + term .)
    >               reduce using rule 45 (expr -> expr + term .)
    )               reduce using rule 45 (expr -> expr + term .)
    *               shift and go to state 82
    /               shift and go to state 83


state 116

    (46) expr -> expr - term .
    (48) term -> term . * factor
    (49) term -> term . / factor

    +               reduce using rule 46 (expr -> expr - term .)
    -               reduce using rule 46 (expr -> expr - term .)
    ;               reduce using rule 46 (expr -> expr - term .)
    ,               reduce using rule 46 (expr -> expr - term .)
    GREATEREQUAL    reduce using rule 46 (expr -> expr - term .)
    EQUALS          reduce using rule 46 (expr -> expr - term .)
    NOTEQUALS       reduce using rule 46 (expr -> expr - term .)
    LOWEREQUAL      reduce using rule 46 (expr -> expr - term .)
    <               reduce using rule 46 (expr -> expr - term .)
    >               reduce using rule 46 (expr -> expr - term .)
    )               reduce using rule 46 (expr -> expr - term .)
    *               shift and go to state 82
    /               shift and go to state 83


state 117

    (48) term -> term * factor .

    *               reduce using rule 48 (term -> term * factor .)
    /               reduce using rule 48 (term -> term * factor .)
    +               reduce using rule 48 (term -> term * factor .)
    -               reduce using rule 48 (term -> term * factor .)
    ;               reduce using rule 48 (term -> term * factor .)
    ,               reduce using rule 48 (term -> term * factor .)
    GREATEREQUAL    reduce using rule 48 (term -> term * factor .)
    EQUALS          reduce using rule 48 (term -> term * factor .)
    NOTEQUALS       reduce using rule 48 (term -> term * factor .)
    LOWEREQUAL      reduce using rule 48 (term -> term * factor .)
    <               reduce using rule 48 (term -> term * factor .)
    >               reduce using rule 48 (term -> term * factor .)
    )               reduce using rule 48 (term -> term * factor .)


state 118

    (49) term -> term / factor .

    *               reduce using rule 49 (term -> term / factor .)
    /               reduce using rule 49 (term -> term / factor .)
    +               reduce using rule 49 (term -> term / factor .)
    -               reduce using rule 49 (term -> term / factor .)
    ;               reduce using rule 49 (term -> term / factor .)
    ,               reduce using rule 49 (term -> term / factor .)
    GREATEREQUAL    reduce using rule 49 (term -> term / factor .)
    EQUALS          reduce using rule 49 (term -> term / factor .)
    NOTEQUALS       reduce using rule 49 (term -> term / factor .)
    LOWEREQUAL      reduce using rule 49 (term -> term / factor .)
    <               reduce using rule 49 (term -> term / factor .)
    >               reduce using rule 49 (term -> term / factor .)
    )               reduce using rule 49 (term -> term / factor .)


state 119

    (51) factor -> ( expr ) .

    *               reduce using rule 51 (factor -> ( expr ) .)
    /               reduce using rule 51 (factor -> ( expr ) .)
    +               reduce using rule 51 (factor -> ( expr ) .)
    -               reduce using rule 51 (factor -> ( expr ) .)
    ;               reduce using rule 51 (factor -> ( expr ) .)
    ,               reduce using rule 51 (factor -> ( expr ) .)
    GREATEREQUAL    reduce using rule 51 (factor -> ( expr ) .)
    EQUALS          reduce using rule 51 (factor -> ( expr ) .)
    NOTEQUALS       reduce using rule 51 (factor -> ( expr ) .)
    LOWEREQUAL      reduce using rule 51 (factor -> ( expr ) .)
    <               reduce using rule 51 (factor -> ( expr ) .)
    >               reduce using rule 51 (factor -> ( expr ) .)
    )               reduce using rule 51 (factor -> ( expr ) .)


state 120

    (73) matrix_expr -> matrix_expr DOTADD matrix_term .
    (76) matrix_term -> matrix_term . DOTMUL matrix_factor
    (77) matrix_term -> matrix_term . DOTDIV matrix_factor

    DOTADD          reduce using rule 73 (matrix_expr -> matrix_expr DOTADD matrix_term .)
    DOTSUB          reduce using rule 73 (matrix_expr -> matrix_expr DOTADD matrix_term .)
    '               reduce using rule 73 (matrix_expr -> matrix_expr DOTADD matrix_term .)
    ;               reduce using rule 73 (matrix_expr -> matrix_expr DOTADD matrix_term .)
    )               reduce using rule 73 (matrix_expr -> matrix_expr DOTADD matrix_term .)
    DOTMUL          shift and go to state 100
    DOTDIV          shift and go to state 101


state 121

    (79) matrix_factor -> ( . matrix_expr )
    (73) matrix_expr -> . matrix_expr DOTADD matrix_term
    (74) matrix_expr -> . matrix_expr DOTSUB matrix_term
    (75) matrix_expr -> . matrix_term
    (76) matrix_term -> . matrix_term DOTMUL matrix_factor
    (77) matrix_term -> . matrix_term DOTDIV matrix_factor
    (78) matrix_term -> . matrix_factor
    (79) matrix_factor -> . ( matrix_expr )
    (80) matrix_factor -> . matrix
    (81) matrix_factor -> . ID
    (60) matrix -> . [ outerlist ]
    (61) matrix -> . ONES ( args_list )
    (62) matrix -> . ZEROS ( args_list )
    (63) matrix -> . EYE ( args_list )

    (               shift and go to state 121
    ID              shift and go to state 122
    [               shift and go to state 60
    ONES            shift and go to state 61
    ZEROS           shift and go to state 63
    EYE             shift and go to state 64

    matrix_expr                    shift and go to state 94
    matrix_term                    shift and go to state 66
    matrix_factor                  shift and go to state 67
    matrix                         shift and go to state 95

state 122

    (81) matrix_factor -> ID .

    DOTMUL          reduce using rule 81 (matrix_factor -> ID .)
    DOTDIV          reduce using rule 81 (matrix_factor -> ID .)
    DOTADD          reduce using rule 81 (matrix_factor -> ID .)
    DOTSUB          reduce using rule 81 (matrix_factor -> ID .)
    '               reduce using rule 81 (matrix_factor -> ID .)
    ;               reduce using rule 81 (matrix_factor -> ID .)
    )               reduce using rule 81 (matrix_factor -> ID .)


state 123

    (74) matrix_expr -> matrix_expr DOTSUB matrix_term .
    (76) matrix_term -> matrix_term . DOTMUL matrix_factor
    (77) matrix_term -> matrix_term . DOTDIV matrix_factor

    DOTADD          reduce using rule 74 (matrix_expr -> matrix_expr DOTSUB matrix_term .)
    DOTSUB          reduce using rule 74 (matrix_expr -> matrix_expr DOTSUB matrix_term .)
    '               reduce using rule 74 (matrix_expr -> matrix_expr DOTSUB matrix_term .)
    ;               reduce using rule 74 (matrix_expr -> matrix_expr DOTSUB matrix_term .)
    )               reduce using rule 74 (matrix_expr -> matrix_expr DOTSUB matrix_term .)
    DOTMUL          shift and go to state 100
    DOTDIV          shift and go to state 101


state 124

    (60) matrix -> [ outerlist ] .

    ;               reduce using rule 60 (matrix -> [ outerlist ] .)
    DOTMUL          reduce using rule 60 (matrix -> [ outerlist ] .)
    DOTDIV          reduce using rule 60 (matrix -> [ outerlist ] .)
    DOTADD          reduce using rule 60 (matrix -> [ outerlist ] .)
    DOTSUB          reduce using rule 60 (matrix -> [ outerlist ] .)
    '               reduce using rule 60 (matrix -> [ outerlist ] .)
    )               reduce using rule 60 (matrix -> [ outerlist ] .)


state 125

    (65) outerlist -> outerlist ; . innerlist
    (67) innerlist -> . innerlist , elem
    (68) innerlist -> . elem
    (69) innerlist -> .
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float
    (84) int -> . INTNUM
    (85) float -> . FLONUM

    ,               reduce using rule 69 (innerlist -> .)
    ]               reduce using rule 69 (innerlist -> .)
    ;               reduce using rule 69 (innerlist -> .)
    ID              shift and go to state 43
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47

    innerlist                      shift and go to state 146
    elem                           shift and go to state 92
    int                            shift and go to state 44
    float                          shift and go to state 45

state 126

    (67) innerlist -> innerlist , . elem
    (70) elem -> . ID
    (71) elem -> . int
    (72) elem -> . float
    (84) int -> . INTNUM
    (85) float -> . FLONUM

    ID              shift and go to state 43
    INTNUM          shift and go to state 46
    FLONUM          shift and go to state 47

    elem                           shift and go to state 147
    int                            shift and go to state 44
    float                          shift and go to state 45

state 127

    (61) matrix -> ONES ( args_list . )
    (28) args_list -> args_list . , expr
    (29) args_list -> args_list . , string

    )               shift and go to state 148
    ,               shift and go to state 79


state 128

    (79) matrix_factor -> ( matrix_expr ) .

    DOTMUL          reduce using rule 79 (matrix_factor -> ( matrix_expr ) .)
    DOTDIV          reduce using rule 79 (matrix_factor -> ( matrix_expr ) .)
    DOTADD          reduce using rule 79 (matrix_factor -> ( matrix_expr ) .)
    DOTSUB          reduce using rule 79 (matrix_factor -> ( matrix_expr ) .)
    '               reduce using rule 79 (matrix_factor -> ( matrix_expr ) .)
    ;               reduce using rule 79 (matrix_factor -> ( matrix_expr ) .)
    )               reduce using rule 79 (matrix_factor -> ( matrix_expr ) .)


state 129

    (62) matrix -> ZEROS ( args_list . )
    (28) args_list -> args_list . , expr
    (29) args_list -> args_list . , string

    )               shift and go to state 149
    ,               shift and go to state 79


state 130

    (63) matrix -> EYE ( args_list . )
    (28) args_list -> args_list . , expr
    (29) args_list -> args_list . , string

    )               shift and go to state 150
    ,               shift and go to state 79


state 131

    (76) matrix_term -> matrix_term DOTMUL matrix_factor .

    DOTMUL          reduce using rule 76 (matrix_term -> matrix_term DOTMUL matrix_factor .)
    DOTDIV          reduce using rule 76 (matrix_term -> matrix_term DOTMUL matrix_factor .)
    DOTADD          reduce using rule 76 (matrix_term -> matrix_term DOTMUL matrix_factor .)
    DOTSUB          reduce using rule 76 (matrix_term -> matrix_term DOTMUL matrix_factor .)
    '               reduce using rule 76 (matrix_term -> matrix_term DOTMUL matrix_factor .)
    ;               reduce using rule 76 (matrix_term -> matrix_term DOTMUL matrix_factor .)
    )               reduce using rule 76 (matrix_term -> matrix_term DOTMUL matrix_factor .)


state 132

    (77) matrix_term -> matrix_term DOTDIV matrix_factor .

    DOTMUL          reduce using rule 77 (matrix_term -> matrix_term DOTDIV matrix_factor .)
    DOTDIV          reduce using rule 77 (matrix_term -> matrix_term DOTDIV matrix_factor .)
    DOTADD          reduce using rule 77 (matrix_term -> matrix_term DOTDIV matrix_factor .)
    DOTSUB          reduce using rule 77 (matrix_term -> matrix_term DOTDIV matrix_factor .)
    '               reduce using rule 77 (matrix_term -> matrix_term DOTDIV matrix_factor .)
    ;               reduce using rule 77 (matrix_term -> matrix_term DOTDIV matrix_factor .)
    )               reduce using rule 77 (matrix_term -> matrix_term DOTDIV matrix_factor .)


state 133

    (59) MID -> ID [ INTNUM , INTNUM . ]

    ]               shift and go to state 151


state 134

    (14) if_instruction -> IF ( relational_expr ) instructions_block .
    (16) if_instruction -> IF ( relational_expr ) instructions_block . ELSE instruction
    (13) instruction -> instructions_block .

  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! reduce/reduce conflict for ID resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for IF resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for FOR resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for WHILE resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for PRINT resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for BREAK resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for RETURN resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for { resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for $end resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for } resolved using rule 13 (instruction -> instructions_block .)
    ELSE            shift and go to state 152
    ID              reduce using rule 13 (instruction -> instructions_block .)
    IF              reduce using rule 13 (instruction -> instructions_block .)
    FOR             reduce using rule 13 (instruction -> instructions_block .)
    WHILE           reduce using rule 13 (instruction -> instructions_block .)
    PRINT           reduce using rule 13 (instruction -> instructions_block .)
    BREAK           reduce using rule 13 (instruction -> instructions_block .)
    CONTINUE        reduce using rule 13 (instruction -> instructions_block .)
    RETURN          reduce using rule 13 (instruction -> instructions_block .)
    {               reduce using rule 13 (instruction -> instructions_block .)
    $end            reduce using rule 13 (instruction -> instructions_block .)
    }               reduce using rule 13 (instruction -> instructions_block .)

  ! ID              [ reduce using rule 14 (if_instruction -> IF ( relational_expr ) instructions_block .) ]
  ! IF              [ reduce using rule 14 (if_instruction -> IF ( relational_expr ) instructions_block .) ]
  ! FOR             [ reduce using rule 14 (if_instruction -> IF ( relational_expr ) instructions_block .) ]
  ! WHILE           [ reduce using rule 14 (if_instruction -> IF ( relational_expr ) instructions_block .) ]
  ! PRINT           [ reduce using rule 14 (if_instruction -> IF ( relational_expr ) instructions_block .) ]
  ! BREAK           [ reduce using rule 14 (if_instruction -> IF ( relational_expr ) instructions_block .) ]
  ! CONTINUE        [ reduce using rule 14 (if_instruction -> IF ( relational_expr ) instructions_block .) ]
  ! RETURN          [ reduce using rule 14 (if_instruction -> IF ( relational_expr ) instructions_block .) ]
  ! {               [ reduce using rule 14 (if_instruction -> IF ( relational_expr ) instructions_block .) ]
  ! $end            [ reduce using rule 14 (if_instruction -> IF ( relational_expr ) instructions_block .) ]
  ! }               [ reduce using rule 14 (if_instruction -> IF ( relational_expr ) instructions_block .) ]
  ! ELSE            [ reduce using rule 14 (if_instruction -> IF ( relational_expr ) instructions_block .) ]
  ! ELSE            [ reduce using rule 13 (instruction -> instructions_block .) ]


state 135

    (15) if_instruction -> IF ( relational_expr ) instruction .
    (17) if_instruction -> IF ( relational_expr ) instruction . ELSE instruction

  ! shift/reduce conflict for ELSE resolved as shift
    ID              reduce using rule 15 (if_instruction -> IF ( relational_expr ) instruction .)
    IF              reduce using rule 15 (if_instruction -> IF ( relational_expr ) instruction .)
    FOR             reduce using rule 15 (if_instruction -> IF ( relational_expr ) instruction .)
    WHILE           reduce using rule 15 (if_instruction -> IF ( relational_expr ) instruction .)
    PRINT           reduce using rule 15 (if_instruction -> IF ( relational_expr ) instruction .)
    BREAK           reduce using rule 15 (if_instruction -> IF ( relational_expr ) instruction .)
    CONTINUE        reduce using rule 15 (if_instruction -> IF ( relational_expr ) instruction .)
    RETURN          reduce using rule 15 (if_instruction -> IF ( relational_expr ) instruction .)
    {               reduce using rule 15 (if_instruction -> IF ( relational_expr ) instruction .)
    $end            reduce using rule 15 (if_instruction -> IF ( relational_expr ) instruction .)
    }               reduce using rule 15 (if_instruction -> IF ( relational_expr ) instruction .)
    ELSE            shift and go to state 153

  ! ELSE            [ reduce using rule 15 (if_instruction -> IF ( relational_expr ) instruction .) ]


state 136

    (53) relational_expr -> expr GREATEREQUAL expr .
    (45) expr -> expr . + term
    (46) expr -> expr . - term

    )               reduce using rule 53 (relational_expr -> expr GREATEREQUAL expr .)
    +               shift and go to state 80
    -               shift and go to state 81


state 137

    (54) relational_expr -> expr EQUALS expr .
    (45) expr -> expr . + term
    (46) expr -> expr . - term

    )               reduce using rule 54 (relational_expr -> expr EQUALS expr .)
    +               shift and go to state 80
    -               shift and go to state 81


state 138

    (55) relational_expr -> expr NOTEQUALS expr .
    (45) expr -> expr . + term
    (46) expr -> expr . - term

    )               reduce using rule 55 (relational_expr -> expr NOTEQUALS expr .)
    +               shift and go to state 80
    -               shift and go to state 81


state 139

    (56) relational_expr -> expr LOWEREQUAL expr .
    (45) expr -> expr . + term
    (46) expr -> expr . - term

    )               reduce using rule 56 (relational_expr -> expr LOWEREQUAL expr .)
    +               shift and go to state 80
    -               shift and go to state 81


state 140

    (57) relational_expr -> expr < expr .
    (45) expr -> expr . + term
    (46) expr -> expr . - term

    )               reduce using rule 57 (relational_expr -> expr < expr .)
    +               shift and go to state 80
    -               shift and go to state 81


state 141

    (58) relational_expr -> expr > expr .
    (45) expr -> expr . + term
    (46) expr -> expr . - term

    )               reduce using rule 58 (relational_expr -> expr > expr .)
    +               shift and go to state 80
    -               shift and go to state 81


state 142

    (20) for_instruction -> FOR ID = ID : . ID instructions_block
    (21) for_instruction -> FOR ID = ID : . ID instruction

    ID              shift and go to state 154


state 143

    (18) for_instruction -> FOR ID = int : . ID instructions_block
    (19) for_instruction -> FOR ID = int : . ID instruction

    ID              shift and go to state 155


state 144

    (22) while_instruction -> WHILE ( relational_expr ) instructions_block .
    (13) instruction -> instructions_block .

  ! reduce/reduce conflict for ELSE resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for ID resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for IF resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for FOR resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for WHILE resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for PRINT resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for BREAK resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for RETURN resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for { resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for $end resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for } resolved using rule 13 (instruction -> instructions_block .)
    ELSE            reduce using rule 13 (instruction -> instructions_block .)
    ID              reduce using rule 13 (instruction -> instructions_block .)
    IF              reduce using rule 13 (instruction -> instructions_block .)
    FOR             reduce using rule 13 (instruction -> instructions_block .)
    WHILE           reduce using rule 13 (instruction -> instructions_block .)
    PRINT           reduce using rule 13 (instruction -> instructions_block .)
    BREAK           reduce using rule 13 (instruction -> instructions_block .)
    CONTINUE        reduce using rule 13 (instruction -> instructions_block .)
    RETURN          reduce using rule 13 (instruction -> instructions_block .)
    {               reduce using rule 13 (instruction -> instructions_block .)
    $end            reduce using rule 13 (instruction -> instructions_block .)
    }               reduce using rule 13 (instruction -> instructions_block .)

  ! ID              [ reduce using rule 22 (while_instruction -> WHILE ( relational_expr ) instructions_block .) ]
  ! IF              [ reduce using rule 22 (while_instruction -> WHILE ( relational_expr ) instructions_block .) ]
  ! FOR             [ reduce using rule 22 (while_instruction -> WHILE ( relational_expr ) instructions_block .) ]
  ! WHILE           [ reduce using rule 22 (while_instruction -> WHILE ( relational_expr ) instructions_block .) ]
  ! PRINT           [ reduce using rule 22 (while_instruction -> WHILE ( relational_expr ) instructions_block .) ]
  ! BREAK           [ reduce using rule 22 (while_instruction -> WHILE ( relational_expr ) instructions_block .) ]
  ! CONTINUE        [ reduce using rule 22 (while_instruction -> WHILE ( relational_expr ) instructions_block .) ]
  ! RETURN          [ reduce using rule 22 (while_instruction -> WHILE ( relational_expr ) instructions_block .) ]
  ! {               [ reduce using rule 22 (while_instruction -> WHILE ( relational_expr ) instructions_block .) ]
  ! $end            [ reduce using rule 22 (while_instruction -> WHILE ( relational_expr ) instructions_block .) ]
  ! }               [ reduce using rule 22 (while_instruction -> WHILE ( relational_expr ) instructions_block .) ]
  ! ELSE            [ reduce using rule 22 (while_instruction -> WHILE ( relational_expr ) instructions_block .) ]


state 145

    (23) while_instruction -> WHILE ( relational_expr ) instruction .

    ID              reduce using rule 23 (while_instruction -> WHILE ( relational_expr ) instruction .)
    IF              reduce using rule 23 (while_instruction -> WHILE ( relational_expr ) instruction .)
    FOR             reduce using rule 23 (while_instruction -> WHILE ( relational_expr ) instruction .)
    WHILE           reduce using rule 23 (while_instruction -> WHILE ( relational_expr ) instruction .)
    PRINT           reduce using rule 23 (while_instruction -> WHILE ( relational_expr ) instruction .)
    BREAK           reduce using rule 23 (while_instruction -> WHILE ( relational_expr ) instruction .)
    CONTINUE        reduce using rule 23 (while_instruction -> WHILE ( relational_expr ) instruction .)
    RETURN          reduce using rule 23 (while_instruction -> WHILE ( relational_expr ) instruction .)
    {               reduce using rule 23 (while_instruction -> WHILE ( relational_expr ) instruction .)
    $end            reduce using rule 23 (while_instruction -> WHILE ( relational_expr ) instruction .)
    }               reduce using rule 23 (while_instruction -> WHILE ( relational_expr ) instruction .)
    ELSE            reduce using rule 23 (while_instruction -> WHILE ( relational_expr ) instruction .)


state 146

    (65) outerlist -> outerlist ; innerlist .
    (67) innerlist -> innerlist . , elem

    ]               reduce using rule 65 (outerlist -> outerlist ; innerlist .)
    ;               reduce using rule 65 (outerlist -> outerlist ; innerlist .)
    ,               shift and go to state 126


state 147

    (67) innerlist -> innerlist , elem .

    ,               reduce using rule 67 (innerlist -> innerlist , elem .)
    ]               reduce using rule 67 (innerlist -> innerlist , elem .)
    ;               reduce using rule 67 (innerlist -> innerlist , elem .)


state 148

    (61) matrix -> ONES ( args_list ) .

    ;               reduce using rule 61 (matrix -> ONES ( args_list ) .)
    DOTMUL          reduce using rule 61 (matrix -> ONES ( args_list ) .)
    DOTDIV          reduce using rule 61 (matrix -> ONES ( args_list ) .)
    DOTADD          reduce using rule 61 (matrix -> ONES ( args_list ) .)
    DOTSUB          reduce using rule 61 (matrix -> ONES ( args_list ) .)
    '               reduce using rule 61 (matrix -> ONES ( args_list ) .)
    )               reduce using rule 61 (matrix -> ONES ( args_list ) .)


state 149

    (62) matrix -> ZEROS ( args_list ) .

    ;               reduce using rule 62 (matrix -> ZEROS ( args_list ) .)
    DOTMUL          reduce using rule 62 (matrix -> ZEROS ( args_list ) .)
    DOTDIV          reduce using rule 62 (matrix -> ZEROS ( args_list ) .)
    DOTADD          reduce using rule 62 (matrix -> ZEROS ( args_list ) .)
    DOTSUB          reduce using rule 62 (matrix -> ZEROS ( args_list ) .)
    '               reduce using rule 62 (matrix -> ZEROS ( args_list ) .)
    )               reduce using rule 62 (matrix -> ZEROS ( args_list ) .)


state 150

    (63) matrix -> EYE ( args_list ) .

    ;               reduce using rule 63 (matrix -> EYE ( args_list ) .)
    DOTMUL          reduce using rule 63 (matrix -> EYE ( args_list ) .)
    DOTDIV          reduce using rule 63 (matrix -> EYE ( args_list ) .)
    DOTADD          reduce using rule 63 (matrix -> EYE ( args_list ) .)
    DOTSUB          reduce using rule 63 (matrix -> EYE ( args_list ) .)
    '               reduce using rule 63 (matrix -> EYE ( args_list ) .)
    )               reduce using rule 63 (matrix -> EYE ( args_list ) .)


state 151

    (59) MID -> ID [ INTNUM , INTNUM ] .

    =               reduce using rule 59 (MID -> ID [ INTNUM , INTNUM ] .)


state 152

    (16) if_instruction -> IF ( relational_expr ) instructions_block ELSE . instruction
    (6) instruction -> . assignment ;
    (7) instruction -> . if_instruction
    (8) instruction -> . for_instruction
    (9) instruction -> . while_instruction
    (10) instruction -> . print_instruction
    (11) instruction -> . loop_instruction
    (12) instruction -> . return_instruction
    (13) instruction -> . instructions_block
    (32) assignment -> . ID = token
    (33) assignment -> . ID ADDASSIGN token
    (34) assignment -> . ID SUBASSIGN token
    (35) assignment -> . ID MULASSIGN token
    (36) assignment -> . ID DIVASSIGN token
    (37) assignment -> . MID = elem
    (14) if_instruction -> . IF ( relational_expr ) instructions_block
    (15) if_instruction -> . IF ( relational_expr ) instruction
    (16) if_instruction -> . IF ( relational_expr ) instructions_block ELSE instruction
    (17) if_instruction -> . IF ( relational_expr ) instruction ELSE instruction
    (18) for_instruction -> . FOR ID = int : ID instructions_block
    (19) for_instruction -> . FOR ID = int : ID instruction
    (20) for_instruction -> . FOR ID = ID : ID instructions_block
    (21) for_instruction -> . FOR ID = ID : ID instruction
    (22) while_instruction -> . WHILE ( relational_expr ) instructions_block
    (23) while_instruction -> . WHILE ( relational_expr ) instruction
    (27) print_instruction -> . PRINT args_list ;
    (24) loop_instruction -> . BREAK ;
    (25) loop_instruction -> . CONTINUE ;
    (26) return_instruction -> . RETURN expr ;
    (3) instructions_block -> . { instructions }
    (59) MID -> . ID [ INTNUM , INTNUM ]

    ID              shift and go to state 13
    IF              shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    PRINT           shift and go to state 18
    BREAK           shift and go to state 19
    CONTINUE        shift and go to state 20
    RETURN          shift and go to state 21
    {               shift and go to state 22

    instructions_block             shift and go to state 12
    instruction                    shift and go to state 156
    assignment                     shift and go to state 5
    if_instruction                 shift and go to state 6
    for_instruction                shift and go to state 7
    while_instruction              shift and go to state 8
    print_instruction              shift and go to state 9
    loop_instruction               shift and go to state 10
    return_instruction             shift and go to state 11
    MID                            shift and go to state 14

state 153

    (17) if_instruction -> IF ( relational_expr ) instruction ELSE . instruction
    (6) instruction -> . assignment ;
    (7) instruction -> . if_instruction
    (8) instruction -> . for_instruction
    (9) instruction -> . while_instruction
    (10) instruction -> . print_instruction
    (11) instruction -> . loop_instruction
    (12) instruction -> . return_instruction
    (13) instruction -> . instructions_block
    (32) assignment -> . ID = token
    (33) assignment -> . ID ADDASSIGN token
    (34) assignment -> . ID SUBASSIGN token
    (35) assignment -> . ID MULASSIGN token
    (36) assignment -> . ID DIVASSIGN token
    (37) assignment -> . MID = elem
    (14) if_instruction -> . IF ( relational_expr ) instructions_block
    (15) if_instruction -> . IF ( relational_expr ) instruction
    (16) if_instruction -> . IF ( relational_expr ) instructions_block ELSE instruction
    (17) if_instruction -> . IF ( relational_expr ) instruction ELSE instruction
    (18) for_instruction -> . FOR ID = int : ID instructions_block
    (19) for_instruction -> . FOR ID = int : ID instruction
    (20) for_instruction -> . FOR ID = ID : ID instructions_block
    (21) for_instruction -> . FOR ID = ID : ID instruction
    (22) while_instruction -> . WHILE ( relational_expr ) instructions_block
    (23) while_instruction -> . WHILE ( relational_expr ) instruction
    (27) print_instruction -> . PRINT args_list ;
    (24) loop_instruction -> . BREAK ;
    (25) loop_instruction -> . CONTINUE ;
    (26) return_instruction -> . RETURN expr ;
    (3) instructions_block -> . { instructions }
    (59) MID -> . ID [ INTNUM , INTNUM ]

    ID              shift and go to state 13
    IF              shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    PRINT           shift and go to state 18
    BREAK           shift and go to state 19
    CONTINUE        shift and go to state 20
    RETURN          shift and go to state 21
    {               shift and go to state 22

    instruction                    shift and go to state 157
    assignment                     shift and go to state 5
    if_instruction                 shift and go to state 6
    for_instruction                shift and go to state 7
    while_instruction              shift and go to state 8
    print_instruction              shift and go to state 9
    loop_instruction               shift and go to state 10
    return_instruction             shift and go to state 11
    instructions_block             shift and go to state 12
    MID                            shift and go to state 14

state 154

    (20) for_instruction -> FOR ID = ID : ID . instructions_block
    (21) for_instruction -> FOR ID = ID : ID . instruction
    (3) instructions_block -> . { instructions }
    (6) instruction -> . assignment ;
    (7) instruction -> . if_instruction
    (8) instruction -> . for_instruction
    (9) instruction -> . while_instruction
    (10) instruction -> . print_instruction
    (11) instruction -> . loop_instruction
    (12) instruction -> . return_instruction
    (13) instruction -> . instructions_block
    (32) assignment -> . ID = token
    (33) assignment -> . ID ADDASSIGN token
    (34) assignment -> . ID SUBASSIGN token
    (35) assignment -> . ID MULASSIGN token
    (36) assignment -> . ID DIVASSIGN token
    (37) assignment -> . MID = elem
    (14) if_instruction -> . IF ( relational_expr ) instructions_block
    (15) if_instruction -> . IF ( relational_expr ) instruction
    (16) if_instruction -> . IF ( relational_expr ) instructions_block ELSE instruction
    (17) if_instruction -> . IF ( relational_expr ) instruction ELSE instruction
    (18) for_instruction -> . FOR ID = int : ID instructions_block
    (19) for_instruction -> . FOR ID = int : ID instruction
    (20) for_instruction -> . FOR ID = ID : ID instructions_block
    (21) for_instruction -> . FOR ID = ID : ID instruction
    (22) while_instruction -> . WHILE ( relational_expr ) instructions_block
    (23) while_instruction -> . WHILE ( relational_expr ) instruction
    (27) print_instruction -> . PRINT args_list ;
    (24) loop_instruction -> . BREAK ;
    (25) loop_instruction -> . CONTINUE ;
    (26) return_instruction -> . RETURN expr ;
    (59) MID -> . ID [ INTNUM , INTNUM ]

    {               shift and go to state 22
    ID              shift and go to state 13
    IF              shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    PRINT           shift and go to state 18
    BREAK           shift and go to state 19
    CONTINUE        shift and go to state 20
    RETURN          shift and go to state 21

    instructions_block             shift and go to state 158
    instruction                    shift and go to state 159
    assignment                     shift and go to state 5
    if_instruction                 shift and go to state 6
    for_instruction                shift and go to state 7
    while_instruction              shift and go to state 8
    print_instruction              shift and go to state 9
    loop_instruction               shift and go to state 10
    return_instruction             shift and go to state 11
    MID                            shift and go to state 14

state 155

    (18) for_instruction -> FOR ID = int : ID . instructions_block
    (19) for_instruction -> FOR ID = int : ID . instruction
    (3) instructions_block -> . { instructions }
    (6) instruction -> . assignment ;
    (7) instruction -> . if_instruction
    (8) instruction -> . for_instruction
    (9) instruction -> . while_instruction
    (10) instruction -> . print_instruction
    (11) instruction -> . loop_instruction
    (12) instruction -> . return_instruction
    (13) instruction -> . instructions_block
    (32) assignment -> . ID = token
    (33) assignment -> . ID ADDASSIGN token
    (34) assignment -> . ID SUBASSIGN token
    (35) assignment -> . ID MULASSIGN token
    (36) assignment -> . ID DIVASSIGN token
    (37) assignment -> . MID = elem
    (14) if_instruction -> . IF ( relational_expr ) instructions_block
    (15) if_instruction -> . IF ( relational_expr ) instruction
    (16) if_instruction -> . IF ( relational_expr ) instructions_block ELSE instruction
    (17) if_instruction -> . IF ( relational_expr ) instruction ELSE instruction
    (18) for_instruction -> . FOR ID = int : ID instructions_block
    (19) for_instruction -> . FOR ID = int : ID instruction
    (20) for_instruction -> . FOR ID = ID : ID instructions_block
    (21) for_instruction -> . FOR ID = ID : ID instruction
    (22) while_instruction -> . WHILE ( relational_expr ) instructions_block
    (23) while_instruction -> . WHILE ( relational_expr ) instruction
    (27) print_instruction -> . PRINT args_list ;
    (24) loop_instruction -> . BREAK ;
    (25) loop_instruction -> . CONTINUE ;
    (26) return_instruction -> . RETURN expr ;
    (59) MID -> . ID [ INTNUM , INTNUM ]

    {               shift and go to state 22
    ID              shift and go to state 13
    IF              shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    PRINT           shift and go to state 18
    BREAK           shift and go to state 19
    CONTINUE        shift and go to state 20
    RETURN          shift and go to state 21

    instructions_block             shift and go to state 160
    instruction                    shift and go to state 161
    assignment                     shift and go to state 5
    if_instruction                 shift and go to state 6
    for_instruction                shift and go to state 7
    while_instruction              shift and go to state 8
    print_instruction              shift and go to state 9
    loop_instruction               shift and go to state 10
    return_instruction             shift and go to state 11
    MID                            shift and go to state 14

state 156

    (16) if_instruction -> IF ( relational_expr ) instructions_block ELSE instruction .

    ID              reduce using rule 16 (if_instruction -> IF ( relational_expr ) instructions_block ELSE instruction .)
    IF              reduce using rule 16 (if_instruction -> IF ( relational_expr ) instructions_block ELSE instruction .)
    FOR             reduce using rule 16 (if_instruction -> IF ( relational_expr ) instructions_block ELSE instruction .)
    WHILE           reduce using rule 16 (if_instruction -> IF ( relational_expr ) instructions_block ELSE instruction .)
    PRINT           reduce using rule 16 (if_instruction -> IF ( relational_expr ) instructions_block ELSE instruction .)
    BREAK           reduce using rule 16 (if_instruction -> IF ( relational_expr ) instructions_block ELSE instruction .)
    CONTINUE        reduce using rule 16 (if_instruction -> IF ( relational_expr ) instructions_block ELSE instruction .)
    RETURN          reduce using rule 16 (if_instruction -> IF ( relational_expr ) instructions_block ELSE instruction .)
    {               reduce using rule 16 (if_instruction -> IF ( relational_expr ) instructions_block ELSE instruction .)
    $end            reduce using rule 16 (if_instruction -> IF ( relational_expr ) instructions_block ELSE instruction .)
    }               reduce using rule 16 (if_instruction -> IF ( relational_expr ) instructions_block ELSE instruction .)
    ELSE            reduce using rule 16 (if_instruction -> IF ( relational_expr ) instructions_block ELSE instruction .)


state 157

    (17) if_instruction -> IF ( relational_expr ) instruction ELSE instruction .

    ID              reduce using rule 17 (if_instruction -> IF ( relational_expr ) instruction ELSE instruction .)
    IF              reduce using rule 17 (if_instruction -> IF ( relational_expr ) instruction ELSE instruction .)
    FOR             reduce using rule 17 (if_instruction -> IF ( relational_expr ) instruction ELSE instruction .)
    WHILE           reduce using rule 17 (if_instruction -> IF ( relational_expr ) instruction ELSE instruction .)
    PRINT           reduce using rule 17 (if_instruction -> IF ( relational_expr ) instruction ELSE instruction .)
    BREAK           reduce using rule 17 (if_instruction -> IF ( relational_expr ) instruction ELSE instruction .)
    CONTINUE        reduce using rule 17 (if_instruction -> IF ( relational_expr ) instruction ELSE instruction .)
    RETURN          reduce using rule 17 (if_instruction -> IF ( relational_expr ) instruction ELSE instruction .)
    {               reduce using rule 17 (if_instruction -> IF ( relational_expr ) instruction ELSE instruction .)
    $end            reduce using rule 17 (if_instruction -> IF ( relational_expr ) instruction ELSE instruction .)
    }               reduce using rule 17 (if_instruction -> IF ( relational_expr ) instruction ELSE instruction .)
    ELSE            reduce using rule 17 (if_instruction -> IF ( relational_expr ) instruction ELSE instruction .)


state 158

    (20) for_instruction -> FOR ID = ID : ID instructions_block .
    (13) instruction -> instructions_block .

  ! reduce/reduce conflict for ELSE resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for ID resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for IF resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for FOR resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for WHILE resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for PRINT resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for BREAK resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for RETURN resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for { resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for $end resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for } resolved using rule 13 (instruction -> instructions_block .)
    ELSE            reduce using rule 13 (instruction -> instructions_block .)
    ID              reduce using rule 13 (instruction -> instructions_block .)
    IF              reduce using rule 13 (instruction -> instructions_block .)
    FOR             reduce using rule 13 (instruction -> instructions_block .)
    WHILE           reduce using rule 13 (instruction -> instructions_block .)
    PRINT           reduce using rule 13 (instruction -> instructions_block .)
    BREAK           reduce using rule 13 (instruction -> instructions_block .)
    CONTINUE        reduce using rule 13 (instruction -> instructions_block .)
    RETURN          reduce using rule 13 (instruction -> instructions_block .)
    {               reduce using rule 13 (instruction -> instructions_block .)
    $end            reduce using rule 13 (instruction -> instructions_block .)
    }               reduce using rule 13 (instruction -> instructions_block .)

  ! ID              [ reduce using rule 20 (for_instruction -> FOR ID = ID : ID instructions_block .) ]
  ! IF              [ reduce using rule 20 (for_instruction -> FOR ID = ID : ID instructions_block .) ]
  ! FOR             [ reduce using rule 20 (for_instruction -> FOR ID = ID : ID instructions_block .) ]
  ! WHILE           [ reduce using rule 20 (for_instruction -> FOR ID = ID : ID instructions_block .) ]
  ! PRINT           [ reduce using rule 20 (for_instruction -> FOR ID = ID : ID instructions_block .) ]
  ! BREAK           [ reduce using rule 20 (for_instruction -> FOR ID = ID : ID instructions_block .) ]
  ! CONTINUE        [ reduce using rule 20 (for_instruction -> FOR ID = ID : ID instructions_block .) ]
  ! RETURN          [ reduce using rule 20 (for_instruction -> FOR ID = ID : ID instructions_block .) ]
  ! {               [ reduce using rule 20 (for_instruction -> FOR ID = ID : ID instructions_block .) ]
  ! $end            [ reduce using rule 20 (for_instruction -> FOR ID = ID : ID instructions_block .) ]
  ! }               [ reduce using rule 20 (for_instruction -> FOR ID = ID : ID instructions_block .) ]
  ! ELSE            [ reduce using rule 20 (for_instruction -> FOR ID = ID : ID instructions_block .) ]


state 159

    (21) for_instruction -> FOR ID = ID : ID instruction .

    ID              reduce using rule 21 (for_instruction -> FOR ID = ID : ID instruction .)
    IF              reduce using rule 21 (for_instruction -> FOR ID = ID : ID instruction .)
    FOR             reduce using rule 21 (for_instruction -> FOR ID = ID : ID instruction .)
    WHILE           reduce using rule 21 (for_instruction -> FOR ID = ID : ID instruction .)
    PRINT           reduce using rule 21 (for_instruction -> FOR ID = ID : ID instruction .)
    BREAK           reduce using rule 21 (for_instruction -> FOR ID = ID : ID instruction .)
    CONTINUE        reduce using rule 21 (for_instruction -> FOR ID = ID : ID instruction .)
    RETURN          reduce using rule 21 (for_instruction -> FOR ID = ID : ID instruction .)
    {               reduce using rule 21 (for_instruction -> FOR ID = ID : ID instruction .)
    $end            reduce using rule 21 (for_instruction -> FOR ID = ID : ID instruction .)
    }               reduce using rule 21 (for_instruction -> FOR ID = ID : ID instruction .)
    ELSE            reduce using rule 21 (for_instruction -> FOR ID = ID : ID instruction .)


state 160

    (18) for_instruction -> FOR ID = int : ID instructions_block .
    (13) instruction -> instructions_block .

  ! reduce/reduce conflict for ELSE resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for ID resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for IF resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for FOR resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for WHILE resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for PRINT resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for BREAK resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for RETURN resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for { resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for $end resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for } resolved using rule 13 (instruction -> instructions_block .)
    ELSE            reduce using rule 13 (instruction -> instructions_block .)
    ID              reduce using rule 13 (instruction -> instructions_block .)
    IF              reduce using rule 13 (instruction -> instructions_block .)
    FOR             reduce using rule 13 (instruction -> instructions_block .)
    WHILE           reduce using rule 13 (instruction -> instructions_block .)
    PRINT           reduce using rule 13 (instruction -> instructions_block .)
    BREAK           reduce using rule 13 (instruction -> instructions_block .)
    CONTINUE        reduce using rule 13 (instruction -> instructions_block .)
    RETURN          reduce using rule 13 (instruction -> instructions_block .)
    {               reduce using rule 13 (instruction -> instructions_block .)
    $end            reduce using rule 13 (instruction -> instructions_block .)
    }               reduce using rule 13 (instruction -> instructions_block .)

  ! ID              [ reduce using rule 18 (for_instruction -> FOR ID = int : ID instructions_block .) ]
  ! IF              [ reduce using rule 18 (for_instruction -> FOR ID = int : ID instructions_block .) ]
  ! FOR             [ reduce using rule 18 (for_instruction -> FOR ID = int : ID instructions_block .) ]
  ! WHILE           [ reduce using rule 18 (for_instruction -> FOR ID = int : ID instructions_block .) ]
  ! PRINT           [ reduce using rule 18 (for_instruction -> FOR ID = int : ID instructions_block .) ]
  ! BREAK           [ reduce using rule 18 (for_instruction -> FOR ID = int : ID instructions_block .) ]
  ! CONTINUE        [ reduce using rule 18 (for_instruction -> FOR ID = int : ID instructions_block .) ]
  ! RETURN          [ reduce using rule 18 (for_instruction -> FOR ID = int : ID instructions_block .) ]
  ! {               [ reduce using rule 18 (for_instruction -> FOR ID = int : ID instructions_block .) ]
  ! $end            [ reduce using rule 18 (for_instruction -> FOR ID = int : ID instructions_block .) ]
  ! }               [ reduce using rule 18 (for_instruction -> FOR ID = int : ID instructions_block .) ]
  ! ELSE            [ reduce using rule 18 (for_instruction -> FOR ID = int : ID instructions_block .) ]


state 161

    (19) for_instruction -> FOR ID = int : ID instruction .

    ID              reduce using rule 19 (for_instruction -> FOR ID = int : ID instruction .)
    IF              reduce using rule 19 (for_instruction -> FOR ID = int : ID instruction .)
    FOR             reduce using rule 19 (for_instruction -> FOR ID = int : ID instruction .)
    WHILE           reduce using rule 19 (for_instruction -> FOR ID = int : ID instruction .)
    PRINT           reduce using rule 19 (for_instruction -> FOR ID = int : ID instruction .)
    BREAK           reduce using rule 19 (for_instruction -> FOR ID = int : ID instruction .)
    CONTINUE        reduce using rule 19 (for_instruction -> FOR ID = int : ID instruction .)
    RETURN          reduce using rule 19 (for_instruction -> FOR ID = int : ID instruction .)
    {               reduce using rule 19 (for_instruction -> FOR ID = int : ID instruction .)
    $end            reduce using rule 19 (for_instruction -> FOR ID = int : ID instruction .)
    }               reduce using rule 19 (for_instruction -> FOR ID = int : ID instruction .)
    ELSE            reduce using rule 19 (for_instruction -> FOR ID = int : ID instruction .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 134 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 134 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 135 resolved as shift
WARNING: reduce/reduce conflict in state 52 resolved using rule (token -> ID)
WARNING: rejected rule (matrix_factor -> ID) in state 52
WARNING: reduce/reduce conflict in state 52 resolved using rule (token -> ID)
WARNING: rejected rule (elem -> ID) in state 52
WARNING: reduce/reduce conflict in state 54 resolved using rule (token -> int)
WARNING: rejected rule (elem -> int) in state 54
WARNING: reduce/reduce conflict in state 55 resolved using rule (token -> float)
WARNING: rejected rule (elem -> float) in state 55
WARNING: reduce/reduce conflict in state 56 resolved using rule (token -> matrix)
WARNING: rejected rule (matrix_factor -> matrix) in state 56
WARNING: reduce/reduce conflict in state 96 resolved using rule (elem -> ID)
WARNING: rejected rule (matrix_factor -> ID) in state 96
WARNING: reduce/reduce conflict in state 134 resolved using rule (instruction -> instructions_block)
WARNING: rejected rule (if_instruction -> IF ( relational_expr ) instructions_block) in state 134
WARNING: reduce/reduce conflict in state 144 resolved using rule (instruction -> instructions_block)
WARNING: rejected rule (while_instruction -> WHILE ( relational_expr ) instructions_block) in state 144
WARNING: reduce/reduce conflict in state 158 resolved using rule (instruction -> instructions_block)
WARNING: rejected rule (for_instruction -> FOR ID = ID : ID instructions_block) in state 158
WARNING: reduce/reduce conflict in state 160 resolved using rule (instruction -> instructions_block)
WARNING: rejected rule (for_instruction -> FOR ID = int : ID instructions_block) in state 160
WARNING: Rule (if_instruction -> IF ( relational_expr ) instructions_block) is never reduced
WARNING: Rule (while_instruction -> WHILE ( relational_expr ) instructions_block) is never reduced
WARNING: Rule (for_instruction -> FOR ID = ID : ID instructions_block) is never reduced
WARNING: Rule (for_instruction -> FOR ID = int : ID instructions_block) is never reduced
