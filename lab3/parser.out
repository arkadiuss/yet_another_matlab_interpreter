Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> program
Rule 1     program -> instructions_opt
Rule 2     instructions_opt -> instructions
Rule 3     instructions_block -> { instructions }
Rule 4     instructions -> instruction instructions
Rule 5     instructions -> instruction
Rule 6     instruction -> assignment ;
Rule 7     instruction -> if_instruction
Rule 8     instruction -> for_instruction
Rule 9     instruction -> while_instruction
Rule 10    instruction -> print_instruction
Rule 11    instruction -> loop_instruction
Rule 12    instruction -> return_instruction
Rule 13    instruction -> instructions_block
Rule 14    if_instruction -> IF ( relational_expr ) instructions_block
Rule 15    if_instruction -> IF ( relational_expr ) instruction
Rule 16    if_instruction -> IF ( relational_expr ) instructions_block ELSE instruction
Rule 17    if_instruction -> IF ( relational_expr ) instruction ELSE instruction
Rule 18    for_instruction -> FOR ID = INTNUM : ID instructions_block
Rule 19    for_instruction -> FOR ID = INTNUM : ID instruction
Rule 20    for_instruction -> FOR ID = ID : ID instructions_block
Rule 21    for_instruction -> FOR ID = ID : ID instruction
Rule 22    while_instruction -> WHILE ( relational_expr ) instructions_block
Rule 23    while_instruction -> WHILE ( relational_expr ) instruction
Rule 24    loop_instruction -> BREAK ;
Rule 25    loop_instruction -> CONTINUE ;
Rule 26    return_instruction -> RETURN expr ;
Rule 27    print_instruction -> PRINT print_list ;
Rule 28    print_list -> print_list , expr
Rule 29    print_list -> print_list , STRING
Rule 30    print_list -> expr
Rule 31    print_list -> STRING
Rule 32    assignment -> ID = token
Rule 33    assignment -> ID ADDASSIGN token
Rule 34    assignment -> ID SUBASSIGN token
Rule 35    assignment -> ID MULASSIGN token
Rule 36    assignment -> ID DIVASSIGN token
Rule 37    assignment -> MID = elem
Rule 38    token -> ID
Rule 39    token -> int
Rule 40    token -> float
Rule 41    token -> matrix
Rule 42    token -> expr
Rule 43    token -> matrix_expr
Rule 44    token -> unary_expr
Rule 45    expr -> expr + term
Rule 46    expr -> expr - term
Rule 47    expr -> term
Rule 48    term -> term * factor
Rule 49    term -> term / factor
Rule 50    term -> factor
Rule 51    factor -> ( expr )
Rule 52    factor -> elem
Rule 53    relational_expr -> expr GREATEREQUAL expr
Rule 54    relational_expr -> expr EQUALS expr
Rule 55    relational_expr -> expr NOTEQUALS expr
Rule 56    relational_expr -> expr LOWEREQUAL expr
Rule 57    relational_expr -> expr < expr
Rule 58    relational_expr -> expr > expr
Rule 59    MID -> ID [ INTNUM , INTNUM ]
Rule 60    matrix -> vector
Rule 61    matrix -> ONES ( int )
Rule 62    matrix -> ZEROS ( int )
Rule 63    matrix -> EYE ( int )
Rule 64    vector -> [ outerlist ]
Rule 65    outerlist -> outerlist , [ innerlist ]
Rule 66    outerlist -> [ innerlist ]
Rule 67    innerlist -> innerlist , elem
Rule 68    innerlist -> elem
Rule 69    elem -> ID
Rule 70    elem -> int
Rule 71    elem -> float
Rule 72    matrix_expr -> matrix_expr DOTADD matrix_term
Rule 73    matrix_expr -> matrix_expr DOTSUB matrix_term
Rule 74    matrix_expr -> matrix_term
Rule 75    matrix_term -> matrix_term DOTMUL matrix_factor
Rule 76    matrix_term -> matrix_term DOTDIV matrix_factor
Rule 77    matrix_term -> matrix_factor
Rule 78    matrix_factor -> ( matrix_expr )
Rule 79    matrix_factor -> matrix
Rule 80    matrix_factor -> ID
Rule 81    unary_expr -> - expr
Rule 82    unary_expr -> matrix_expr '
Rule 83    int -> INTNUM
Rule 84    float -> FLONUM

Terminals, with rules where they appear

'                    : 82
(                    : 14 15 16 17 22 23 51 61 62 63 78
)                    : 14 15 16 17 22 23 51 61 62 63 78
*                    : 48
+                    : 45
,                    : 28 29 59 65 67
-                    : 46 81
/                    : 49
:                    : 18 19 20 21
;                    : 6 24 25 26 27
<                    : 57
=                    : 18 19 20 21 32 37
>                    : 58
ADDASSIGN            : 33
BREAK                : 24
COMMENT              : 
CONTINUE             : 25
DIVASSIGN            : 36
DOTADD               : 72
DOTDIV               : 76
DOTMUL               : 75
DOTSUB               : 73
ELSE                 : 16 17
EQUALS               : 54
EYE                  : 63
FLONUM               : 84
FOR                  : 18 19 20 21
GREATEREQUAL         : 53
ID                   : 18 18 19 19 20 20 20 21 21 21 32 33 34 35 36 38 59 69 80
IF                   : 14 15 16 17
INTNUM               : 18 19 59 59 83
LOWEREQUAL           : 56
MULASSIGN            : 35
NOTEQUALS            : 55
ONES                 : 61
PRINT                : 27
RETURN               : 26
STRING               : 29 31
SUBASSIGN            : 34
WHILE                : 22 23
ZEROS                : 62
[                    : 59 64 65 66
]                    : 59 64 65 66
error                : 
{                    : 3
}                    : 3

Nonterminals, with rules where they appear

MID                  : 37
assignment           : 6
elem                 : 37 52 67 68
expr                 : 26 28 30 42 45 46 51 53 53 54 54 55 55 56 56 57 57 58 58 81
factor               : 48 49 50
float                : 40 71
for_instruction      : 8
if_instruction       : 7
innerlist            : 65 66 67
instruction          : 4 5 15 16 17 17 19 21 23
instructions         : 2 3 4
instructions_block   : 13 14 16 18 20 22
instructions_opt     : 1
int                  : 39 61 62 63 70
loop_instruction     : 11
matrix               : 41 79
matrix_expr          : 43 72 73 78 82
matrix_factor        : 75 76 77
matrix_term          : 72 73 74 75 76
outerlist            : 64 65
print_instruction    : 10
print_list           : 27 28 29
program              : 0
relational_expr      : 14 15 16 17 22 23
return_instruction   : 12
term                 : 45 46 47 48 49
token                : 32 33 34 35 36
unary_expr           : 44
vector               : 60
while_instruction    : 9

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . instructions_opt
    (2) instructions_opt -> . instructions
    (4) instructions -> . instruction instructions
    (5) instructions -> . instruction
    (6) instruction -> . assignment ;
    (7) instruction -> . if_instruction
    (8) instruction -> . for_instruction
    (9) instruction -> . while_instruction
    (10) instruction -> . print_instruction
    (11) instruction -> . loop_instruction
    (12) instruction -> . return_instruction
    (13) instruction -> . instructions_block
    (32) assignment -> . ID = token
    (33) assignment -> . ID ADDASSIGN token
    (34) assignment -> . ID SUBASSIGN token
    (35) assignment -> . ID MULASSIGN token
    (36) assignment -> . ID DIVASSIGN token
    (37) assignment -> . MID = elem
    (14) if_instruction -> . IF ( relational_expr ) instructions_block
    (15) if_instruction -> . IF ( relational_expr ) instruction
    (16) if_instruction -> . IF ( relational_expr ) instructions_block ELSE instruction
    (17) if_instruction -> . IF ( relational_expr ) instruction ELSE instruction
    (18) for_instruction -> . FOR ID = INTNUM : ID instructions_block
    (19) for_instruction -> . FOR ID = INTNUM : ID instruction
    (20) for_instruction -> . FOR ID = ID : ID instructions_block
    (21) for_instruction -> . FOR ID = ID : ID instruction
    (22) while_instruction -> . WHILE ( relational_expr ) instructions_block
    (23) while_instruction -> . WHILE ( relational_expr ) instruction
    (27) print_instruction -> . PRINT print_list ;
    (24) loop_instruction -> . BREAK ;
    (25) loop_instruction -> . CONTINUE ;
    (26) return_instruction -> . RETURN expr ;
    (3) instructions_block -> . { instructions }
    (59) MID -> . ID [ INTNUM , INTNUM ]

    ID              shift and go to state 13
    IF              shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    PRINT           shift and go to state 18
    BREAK           shift and go to state 19
    CONTINUE        shift and go to state 20
    RETURN          shift and go to state 21
    {               shift and go to state 22

    program                        shift and go to state 1
    instructions_opt               shift and go to state 2
    instructions                   shift and go to state 3
    instruction                    shift and go to state 4
    assignment                     shift and go to state 5
    if_instruction                 shift and go to state 6
    for_instruction                shift and go to state 7
    while_instruction              shift and go to state 8
    print_instruction              shift and go to state 9
    loop_instruction               shift and go to state 10
    return_instruction             shift and go to state 11
    instructions_block             shift and go to state 12
    MID                            shift and go to state 14

state 1

    (0) S' -> program .



state 2

    (1) program -> instructions_opt .

    $end            reduce using rule 1 (program -> instructions_opt .)


state 3

    (2) instructions_opt -> instructions .

    $end            reduce using rule 2 (instructions_opt -> instructions .)


state 4

    (4) instructions -> instruction . instructions
    (5) instructions -> instruction .
    (4) instructions -> . instruction instructions
    (5) instructions -> . instruction
    (6) instruction -> . assignment ;
    (7) instruction -> . if_instruction
    (8) instruction -> . for_instruction
    (9) instruction -> . while_instruction
    (10) instruction -> . print_instruction
    (11) instruction -> . loop_instruction
    (12) instruction -> . return_instruction
    (13) instruction -> . instructions_block
    (32) assignment -> . ID = token
    (33) assignment -> . ID ADDASSIGN token
    (34) assignment -> . ID SUBASSIGN token
    (35) assignment -> . ID MULASSIGN token
    (36) assignment -> . ID DIVASSIGN token
    (37) assignment -> . MID = elem
    (14) if_instruction -> . IF ( relational_expr ) instructions_block
    (15) if_instruction -> . IF ( relational_expr ) instruction
    (16) if_instruction -> . IF ( relational_expr ) instructions_block ELSE instruction
    (17) if_instruction -> . IF ( relational_expr ) instruction ELSE instruction
    (18) for_instruction -> . FOR ID = INTNUM : ID instructions_block
    (19) for_instruction -> . FOR ID = INTNUM : ID instruction
    (20) for_instruction -> . FOR ID = ID : ID instructions_block
    (21) for_instruction -> . FOR ID = ID : ID instruction
    (22) while_instruction -> . WHILE ( relational_expr ) instructions_block
    (23) while_instruction -> . WHILE ( relational_expr ) instruction
    (27) print_instruction -> . PRINT print_list ;
    (24) loop_instruction -> . BREAK ;
    (25) loop_instruction -> . CONTINUE ;
    (26) return_instruction -> . RETURN expr ;
    (3) instructions_block -> . { instructions }
    (59) MID -> . ID [ INTNUM , INTNUM ]

    $end            reduce using rule 5 (instructions -> instruction .)
    }               reduce using rule 5 (instructions -> instruction .)
    ID              shift and go to state 13
    IF              shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    PRINT           shift and go to state 18
    BREAK           shift and go to state 19
    CONTINUE        shift and go to state 20
    RETURN          shift and go to state 21
    {               shift and go to state 22

    instruction                    shift and go to state 4
    instructions                   shift and go to state 23
    assignment                     shift and go to state 5
    if_instruction                 shift and go to state 6
    for_instruction                shift and go to state 7
    while_instruction              shift and go to state 8
    print_instruction              shift and go to state 9
    loop_instruction               shift and go to state 10
    return_instruction             shift and go to state 11
    instructions_block             shift and go to state 12
    MID                            shift and go to state 14

state 5

    (6) instruction -> assignment . ;

    ;               shift and go to state 24


state 6

    (7) instruction -> if_instruction .

    ID              reduce using rule 7 (instruction -> if_instruction .)
    IF              reduce using rule 7 (instruction -> if_instruction .)
    FOR             reduce using rule 7 (instruction -> if_instruction .)
    WHILE           reduce using rule 7 (instruction -> if_instruction .)
    PRINT           reduce using rule 7 (instruction -> if_instruction .)
    BREAK           reduce using rule 7 (instruction -> if_instruction .)
    CONTINUE        reduce using rule 7 (instruction -> if_instruction .)
    RETURN          reduce using rule 7 (instruction -> if_instruction .)
    {               reduce using rule 7 (instruction -> if_instruction .)
    $end            reduce using rule 7 (instruction -> if_instruction .)
    }               reduce using rule 7 (instruction -> if_instruction .)
    ELSE            reduce using rule 7 (instruction -> if_instruction .)


state 7

    (8) instruction -> for_instruction .

    ID              reduce using rule 8 (instruction -> for_instruction .)
    IF              reduce using rule 8 (instruction -> for_instruction .)
    FOR             reduce using rule 8 (instruction -> for_instruction .)
    WHILE           reduce using rule 8 (instruction -> for_instruction .)
    PRINT           reduce using rule 8 (instruction -> for_instruction .)
    BREAK           reduce using rule 8 (instruction -> for_instruction .)
    CONTINUE        reduce using rule 8 (instruction -> for_instruction .)
    RETURN          reduce using rule 8 (instruction -> for_instruction .)
    {               reduce using rule 8 (instruction -> for_instruction .)
    $end            reduce using rule 8 (instruction -> for_instruction .)
    }               reduce using rule 8 (instruction -> for_instruction .)
    ELSE            reduce using rule 8 (instruction -> for_instruction .)


state 8

    (9) instruction -> while_instruction .

    ID              reduce using rule 9 (instruction -> while_instruction .)
    IF              reduce using rule 9 (instruction -> while_instruction .)
    FOR             reduce using rule 9 (instruction -> while_instruction .)
    WHILE           reduce using rule 9 (instruction -> while_instruction .)
    PRINT           reduce using rule 9 (instruction -> while_instruction .)
    BREAK           reduce using rule 9 (instruction -> while_instruction .)
    CONTINUE        reduce using rule 9 (instruction -> while_instruction .)
    RETURN          reduce using rule 9 (instruction -> while_instruction .)
    {               reduce using rule 9 (instruction -> while_instruction .)
    $end            reduce using rule 9 (instruction -> while_instruction .)
    }               reduce using rule 9 (instruction -> while_instruction .)
    ELSE            reduce using rule 9 (instruction -> while_instruction .)


state 9

    (10) instruction -> print_instruction .

    ID              reduce using rule 10 (instruction -> print_instruction .)
    IF              reduce using rule 10 (instruction -> print_instruction .)
    FOR             reduce using rule 10 (instruction -> print_instruction .)
    WHILE           reduce using rule 10 (instruction -> print_instruction .)
    PRINT           reduce using rule 10 (instruction -> print_instruction .)
    BREAK           reduce using rule 10 (instruction -> print_instruction .)
    CONTINUE        reduce using rule 10 (instruction -> print_instruction .)
    RETURN          reduce using rule 10 (instruction -> print_instruction .)
    {               reduce using rule 10 (instruction -> print_instruction .)
    $end            reduce using rule 10 (instruction -> print_instruction .)
    }               reduce using rule 10 (instruction -> print_instruction .)
    ELSE            reduce using rule 10 (instruction -> print_instruction .)


state 10

    (11) instruction -> loop_instruction .

    ID              reduce using rule 11 (instruction -> loop_instruction .)
    IF              reduce using rule 11 (instruction -> loop_instruction .)
    FOR             reduce using rule 11 (instruction -> loop_instruction .)
    WHILE           reduce using rule 11 (instruction -> loop_instruction .)
    PRINT           reduce using rule 11 (instruction -> loop_instruction .)
    BREAK           reduce using rule 11 (instruction -> loop_instruction .)
    CONTINUE        reduce using rule 11 (instruction -> loop_instruction .)
    RETURN          reduce using rule 11 (instruction -> loop_instruction .)
    {               reduce using rule 11 (instruction -> loop_instruction .)
    $end            reduce using rule 11 (instruction -> loop_instruction .)
    }               reduce using rule 11 (instruction -> loop_instruction .)
    ELSE            reduce using rule 11 (instruction -> loop_instruction .)


state 11

    (12) instruction -> return_instruction .

    ID              reduce using rule 12 (instruction -> return_instruction .)
    IF              reduce using rule 12 (instruction -> return_instruction .)
    FOR             reduce using rule 12 (instruction -> return_instruction .)
    WHILE           reduce using rule 12 (instruction -> return_instruction .)
    PRINT           reduce using rule 12 (instruction -> return_instruction .)
    BREAK           reduce using rule 12 (instruction -> return_instruction .)
    CONTINUE        reduce using rule 12 (instruction -> return_instruction .)
    RETURN          reduce using rule 12 (instruction -> return_instruction .)
    {               reduce using rule 12 (instruction -> return_instruction .)
    $end            reduce using rule 12 (instruction -> return_instruction .)
    }               reduce using rule 12 (instruction -> return_instruction .)
    ELSE            reduce using rule 12 (instruction -> return_instruction .)


state 12

    (13) instruction -> instructions_block .

    ID              reduce using rule 13 (instruction -> instructions_block .)
    IF              reduce using rule 13 (instruction -> instructions_block .)
    FOR             reduce using rule 13 (instruction -> instructions_block .)
    WHILE           reduce using rule 13 (instruction -> instructions_block .)
    PRINT           reduce using rule 13 (instruction -> instructions_block .)
    BREAK           reduce using rule 13 (instruction -> instructions_block .)
    CONTINUE        reduce using rule 13 (instruction -> instructions_block .)
    RETURN          reduce using rule 13 (instruction -> instructions_block .)
    {               reduce using rule 13 (instruction -> instructions_block .)
    $end            reduce using rule 13 (instruction -> instructions_block .)
    }               reduce using rule 13 (instruction -> instructions_block .)
    ELSE            reduce using rule 13 (instruction -> instructions_block .)


state 13

    (32) assignment -> ID . = token
    (33) assignment -> ID . ADDASSIGN token
    (34) assignment -> ID . SUBASSIGN token
    (35) assignment -> ID . MULASSIGN token
    (36) assignment -> ID . DIVASSIGN token
    (59) MID -> ID . [ INTNUM , INTNUM ]

    =               shift and go to state 25
    ADDASSIGN       shift and go to state 26
    SUBASSIGN       shift and go to state 27
    MULASSIGN       shift and go to state 28
    DIVASSIGN       shift and go to state 29
    [               shift and go to state 30


state 14

    (37) assignment -> MID . = elem

    =               shift and go to state 31


state 15

    (14) if_instruction -> IF . ( relational_expr ) instructions_block
    (15) if_instruction -> IF . ( relational_expr ) instruction
    (16) if_instruction -> IF . ( relational_expr ) instructions_block ELSE instruction
    (17) if_instruction -> IF . ( relational_expr ) instruction ELSE instruction

    (               shift and go to state 32


state 16

    (18) for_instruction -> FOR . ID = INTNUM : ID instructions_block
    (19) for_instruction -> FOR . ID = INTNUM : ID instruction
    (20) for_instruction -> FOR . ID = ID : ID instructions_block
    (21) for_instruction -> FOR . ID = ID : ID instruction

    ID              shift and go to state 33


state 17

    (22) while_instruction -> WHILE . ( relational_expr ) instructions_block
    (23) while_instruction -> WHILE . ( relational_expr ) instruction

    (               shift and go to state 34


state 18

    (27) print_instruction -> PRINT . print_list ;
    (28) print_list -> . print_list , expr
    (29) print_list -> . print_list , STRING
    (30) print_list -> . expr
    (31) print_list -> . STRING
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (69) elem -> . ID
    (70) elem -> . int
    (71) elem -> . float
    (83) int -> . INTNUM
    (84) float -> . FLONUM

    STRING          shift and go to state 37
    (               shift and go to state 40
    ID              shift and go to state 42
    INTNUM          shift and go to state 45
    FLONUM          shift and go to state 46

    print_list                     shift and go to state 35
    expr                           shift and go to state 36
    term                           shift and go to state 38
    factor                         shift and go to state 39
    elem                           shift and go to state 41
    int                            shift and go to state 43
    float                          shift and go to state 44

state 19

    (24) loop_instruction -> BREAK . ;

    ;               shift and go to state 47


state 20

    (25) loop_instruction -> CONTINUE . ;

    ;               shift and go to state 48


state 21

    (26) return_instruction -> RETURN . expr ;
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (69) elem -> . ID
    (70) elem -> . int
    (71) elem -> . float
    (83) int -> . INTNUM
    (84) float -> . FLONUM

    (               shift and go to state 40
    ID              shift and go to state 42
    INTNUM          shift and go to state 45
    FLONUM          shift and go to state 46

    expr                           shift and go to state 49
    term                           shift and go to state 38
    factor                         shift and go to state 39
    elem                           shift and go to state 41
    int                            shift and go to state 43
    float                          shift and go to state 44

state 22

    (3) instructions_block -> { . instructions }
    (4) instructions -> . instruction instructions
    (5) instructions -> . instruction
    (6) instruction -> . assignment ;
    (7) instruction -> . if_instruction
    (8) instruction -> . for_instruction
    (9) instruction -> . while_instruction
    (10) instruction -> . print_instruction
    (11) instruction -> . loop_instruction
    (12) instruction -> . return_instruction
    (13) instruction -> . instructions_block
    (32) assignment -> . ID = token
    (33) assignment -> . ID ADDASSIGN token
    (34) assignment -> . ID SUBASSIGN token
    (35) assignment -> . ID MULASSIGN token
    (36) assignment -> . ID DIVASSIGN token
    (37) assignment -> . MID = elem
    (14) if_instruction -> . IF ( relational_expr ) instructions_block
    (15) if_instruction -> . IF ( relational_expr ) instruction
    (16) if_instruction -> . IF ( relational_expr ) instructions_block ELSE instruction
    (17) if_instruction -> . IF ( relational_expr ) instruction ELSE instruction
    (18) for_instruction -> . FOR ID = INTNUM : ID instructions_block
    (19) for_instruction -> . FOR ID = INTNUM : ID instruction
    (20) for_instruction -> . FOR ID = ID : ID instructions_block
    (21) for_instruction -> . FOR ID = ID : ID instruction
    (22) while_instruction -> . WHILE ( relational_expr ) instructions_block
    (23) while_instruction -> . WHILE ( relational_expr ) instruction
    (27) print_instruction -> . PRINT print_list ;
    (24) loop_instruction -> . BREAK ;
    (25) loop_instruction -> . CONTINUE ;
    (26) return_instruction -> . RETURN expr ;
    (3) instructions_block -> . { instructions }
    (59) MID -> . ID [ INTNUM , INTNUM ]

    ID              shift and go to state 13
    IF              shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    PRINT           shift and go to state 18
    BREAK           shift and go to state 19
    CONTINUE        shift and go to state 20
    RETURN          shift and go to state 21
    {               shift and go to state 22

    instructions                   shift and go to state 50
    instruction                    shift and go to state 4
    assignment                     shift and go to state 5
    if_instruction                 shift and go to state 6
    for_instruction                shift and go to state 7
    while_instruction              shift and go to state 8
    print_instruction              shift and go to state 9
    loop_instruction               shift and go to state 10
    return_instruction             shift and go to state 11
    instructions_block             shift and go to state 12
    MID                            shift and go to state 14

state 23

    (4) instructions -> instruction instructions .

    $end            reduce using rule 4 (instructions -> instruction instructions .)
    }               reduce using rule 4 (instructions -> instruction instructions .)


state 24

    (6) instruction -> assignment ; .

    ID              reduce using rule 6 (instruction -> assignment ; .)
    IF              reduce using rule 6 (instruction -> assignment ; .)
    FOR             reduce using rule 6 (instruction -> assignment ; .)
    WHILE           reduce using rule 6 (instruction -> assignment ; .)
    PRINT           reduce using rule 6 (instruction -> assignment ; .)
    BREAK           reduce using rule 6 (instruction -> assignment ; .)
    CONTINUE        reduce using rule 6 (instruction -> assignment ; .)
    RETURN          reduce using rule 6 (instruction -> assignment ; .)
    {               reduce using rule 6 (instruction -> assignment ; .)
    $end            reduce using rule 6 (instruction -> assignment ; .)
    }               reduce using rule 6 (instruction -> assignment ; .)
    ELSE            reduce using rule 6 (instruction -> assignment ; .)


state 25

    (32) assignment -> ID = . token
    (38) token -> . ID
    (39) token -> . int
    (40) token -> . float
    (41) token -> . matrix
    (42) token -> . expr
    (43) token -> . matrix_expr
    (44) token -> . unary_expr
    (83) int -> . INTNUM
    (84) float -> . FLONUM
    (60) matrix -> . vector
    (61) matrix -> . ONES ( int )
    (62) matrix -> . ZEROS ( int )
    (63) matrix -> . EYE ( int )
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (72) matrix_expr -> . matrix_expr DOTADD matrix_term
    (73) matrix_expr -> . matrix_expr DOTSUB matrix_term
    (74) matrix_expr -> . matrix_term
    (81) unary_expr -> . - expr
    (82) unary_expr -> . matrix_expr '
    (64) vector -> . [ outerlist ]
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (75) matrix_term -> . matrix_term DOTMUL matrix_factor
    (76) matrix_term -> . matrix_term DOTDIV matrix_factor
    (77) matrix_term -> . matrix_factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (78) matrix_factor -> . ( matrix_expr )
    (79) matrix_factor -> . matrix
    (80) matrix_factor -> . ID
    (69) elem -> . ID
    (70) elem -> . int
    (71) elem -> . float

    ID              shift and go to state 51
    INTNUM          shift and go to state 45
    FLONUM          shift and go to state 46
    ONES            shift and go to state 60
    ZEROS           shift and go to state 62
    EYE             shift and go to state 63
    -               shift and go to state 64
    [               shift and go to state 66
    (               shift and go to state 61

    token                          shift and go to state 52
    int                            shift and go to state 53
    float                          shift and go to state 54
    matrix                         shift and go to state 55
    expr                           shift and go to state 56
    matrix_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    vector                         shift and go to state 59
    term                           shift and go to state 38
    matrix_term                    shift and go to state 65
    factor                         shift and go to state 39
    matrix_factor                  shift and go to state 67
    elem                           shift and go to state 41

state 26

    (33) assignment -> ID ADDASSIGN . token
    (38) token -> . ID
    (39) token -> . int
    (40) token -> . float
    (41) token -> . matrix
    (42) token -> . expr
    (43) token -> . matrix_expr
    (44) token -> . unary_expr
    (83) int -> . INTNUM
    (84) float -> . FLONUM
    (60) matrix -> . vector
    (61) matrix -> . ONES ( int )
    (62) matrix -> . ZEROS ( int )
    (63) matrix -> . EYE ( int )
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (72) matrix_expr -> . matrix_expr DOTADD matrix_term
    (73) matrix_expr -> . matrix_expr DOTSUB matrix_term
    (74) matrix_expr -> . matrix_term
    (81) unary_expr -> . - expr
    (82) unary_expr -> . matrix_expr '
    (64) vector -> . [ outerlist ]
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (75) matrix_term -> . matrix_term DOTMUL matrix_factor
    (76) matrix_term -> . matrix_term DOTDIV matrix_factor
    (77) matrix_term -> . matrix_factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (78) matrix_factor -> . ( matrix_expr )
    (79) matrix_factor -> . matrix
    (80) matrix_factor -> . ID
    (69) elem -> . ID
    (70) elem -> . int
    (71) elem -> . float

    ID              shift and go to state 51
    INTNUM          shift and go to state 45
    FLONUM          shift and go to state 46
    ONES            shift and go to state 60
    ZEROS           shift and go to state 62
    EYE             shift and go to state 63
    -               shift and go to state 64
    [               shift and go to state 66
    (               shift and go to state 61

    token                          shift and go to state 68
    int                            shift and go to state 53
    float                          shift and go to state 54
    matrix                         shift and go to state 55
    expr                           shift and go to state 56
    matrix_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    vector                         shift and go to state 59
    term                           shift and go to state 38
    matrix_term                    shift and go to state 65
    factor                         shift and go to state 39
    matrix_factor                  shift and go to state 67
    elem                           shift and go to state 41

state 27

    (34) assignment -> ID SUBASSIGN . token
    (38) token -> . ID
    (39) token -> . int
    (40) token -> . float
    (41) token -> . matrix
    (42) token -> . expr
    (43) token -> . matrix_expr
    (44) token -> . unary_expr
    (83) int -> . INTNUM
    (84) float -> . FLONUM
    (60) matrix -> . vector
    (61) matrix -> . ONES ( int )
    (62) matrix -> . ZEROS ( int )
    (63) matrix -> . EYE ( int )
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (72) matrix_expr -> . matrix_expr DOTADD matrix_term
    (73) matrix_expr -> . matrix_expr DOTSUB matrix_term
    (74) matrix_expr -> . matrix_term
    (81) unary_expr -> . - expr
    (82) unary_expr -> . matrix_expr '
    (64) vector -> . [ outerlist ]
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (75) matrix_term -> . matrix_term DOTMUL matrix_factor
    (76) matrix_term -> . matrix_term DOTDIV matrix_factor
    (77) matrix_term -> . matrix_factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (78) matrix_factor -> . ( matrix_expr )
    (79) matrix_factor -> . matrix
    (80) matrix_factor -> . ID
    (69) elem -> . ID
    (70) elem -> . int
    (71) elem -> . float

    ID              shift and go to state 51
    INTNUM          shift and go to state 45
    FLONUM          shift and go to state 46
    ONES            shift and go to state 60
    ZEROS           shift and go to state 62
    EYE             shift and go to state 63
    -               shift and go to state 64
    [               shift and go to state 66
    (               shift and go to state 61

    token                          shift and go to state 69
    int                            shift and go to state 53
    float                          shift and go to state 54
    matrix                         shift and go to state 55
    expr                           shift and go to state 56
    matrix_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    vector                         shift and go to state 59
    term                           shift and go to state 38
    matrix_term                    shift and go to state 65
    factor                         shift and go to state 39
    matrix_factor                  shift and go to state 67
    elem                           shift and go to state 41

state 28

    (35) assignment -> ID MULASSIGN . token
    (38) token -> . ID
    (39) token -> . int
    (40) token -> . float
    (41) token -> . matrix
    (42) token -> . expr
    (43) token -> . matrix_expr
    (44) token -> . unary_expr
    (83) int -> . INTNUM
    (84) float -> . FLONUM
    (60) matrix -> . vector
    (61) matrix -> . ONES ( int )
    (62) matrix -> . ZEROS ( int )
    (63) matrix -> . EYE ( int )
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (72) matrix_expr -> . matrix_expr DOTADD matrix_term
    (73) matrix_expr -> . matrix_expr DOTSUB matrix_term
    (74) matrix_expr -> . matrix_term
    (81) unary_expr -> . - expr
    (82) unary_expr -> . matrix_expr '
    (64) vector -> . [ outerlist ]
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (75) matrix_term -> . matrix_term DOTMUL matrix_factor
    (76) matrix_term -> . matrix_term DOTDIV matrix_factor
    (77) matrix_term -> . matrix_factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (78) matrix_factor -> . ( matrix_expr )
    (79) matrix_factor -> . matrix
    (80) matrix_factor -> . ID
    (69) elem -> . ID
    (70) elem -> . int
    (71) elem -> . float

    ID              shift and go to state 51
    INTNUM          shift and go to state 45
    FLONUM          shift and go to state 46
    ONES            shift and go to state 60
    ZEROS           shift and go to state 62
    EYE             shift and go to state 63
    -               shift and go to state 64
    [               shift and go to state 66
    (               shift and go to state 61

    token                          shift and go to state 70
    int                            shift and go to state 53
    float                          shift and go to state 54
    matrix                         shift and go to state 55
    expr                           shift and go to state 56
    matrix_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    vector                         shift and go to state 59
    term                           shift and go to state 38
    matrix_term                    shift and go to state 65
    factor                         shift and go to state 39
    matrix_factor                  shift and go to state 67
    elem                           shift and go to state 41

state 29

    (36) assignment -> ID DIVASSIGN . token
    (38) token -> . ID
    (39) token -> . int
    (40) token -> . float
    (41) token -> . matrix
    (42) token -> . expr
    (43) token -> . matrix_expr
    (44) token -> . unary_expr
    (83) int -> . INTNUM
    (84) float -> . FLONUM
    (60) matrix -> . vector
    (61) matrix -> . ONES ( int )
    (62) matrix -> . ZEROS ( int )
    (63) matrix -> . EYE ( int )
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (72) matrix_expr -> . matrix_expr DOTADD matrix_term
    (73) matrix_expr -> . matrix_expr DOTSUB matrix_term
    (74) matrix_expr -> . matrix_term
    (81) unary_expr -> . - expr
    (82) unary_expr -> . matrix_expr '
    (64) vector -> . [ outerlist ]
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (75) matrix_term -> . matrix_term DOTMUL matrix_factor
    (76) matrix_term -> . matrix_term DOTDIV matrix_factor
    (77) matrix_term -> . matrix_factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (78) matrix_factor -> . ( matrix_expr )
    (79) matrix_factor -> . matrix
    (80) matrix_factor -> . ID
    (69) elem -> . ID
    (70) elem -> . int
    (71) elem -> . float

    ID              shift and go to state 51
    INTNUM          shift and go to state 45
    FLONUM          shift and go to state 46
    ONES            shift and go to state 60
    ZEROS           shift and go to state 62
    EYE             shift and go to state 63
    -               shift and go to state 64
    [               shift and go to state 66
    (               shift and go to state 61

    token                          shift and go to state 71
    int                            shift and go to state 53
    float                          shift and go to state 54
    matrix                         shift and go to state 55
    expr                           shift and go to state 56
    matrix_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    vector                         shift and go to state 59
    term                           shift and go to state 38
    matrix_term                    shift and go to state 65
    factor                         shift and go to state 39
    matrix_factor                  shift and go to state 67
    elem                           shift and go to state 41

state 30

    (59) MID -> ID [ . INTNUM , INTNUM ]

    INTNUM          shift and go to state 72


state 31

    (37) assignment -> MID = . elem
    (69) elem -> . ID
    (70) elem -> . int
    (71) elem -> . float
    (83) int -> . INTNUM
    (84) float -> . FLONUM

    ID              shift and go to state 42
    INTNUM          shift and go to state 45
    FLONUM          shift and go to state 46

    elem                           shift and go to state 73
    int                            shift and go to state 43
    float                          shift and go to state 44

state 32

    (14) if_instruction -> IF ( . relational_expr ) instructions_block
    (15) if_instruction -> IF ( . relational_expr ) instruction
    (16) if_instruction -> IF ( . relational_expr ) instructions_block ELSE instruction
    (17) if_instruction -> IF ( . relational_expr ) instruction ELSE instruction
    (53) relational_expr -> . expr GREATEREQUAL expr
    (54) relational_expr -> . expr EQUALS expr
    (55) relational_expr -> . expr NOTEQUALS expr
    (56) relational_expr -> . expr LOWEREQUAL expr
    (57) relational_expr -> . expr < expr
    (58) relational_expr -> . expr > expr
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (69) elem -> . ID
    (70) elem -> . int
    (71) elem -> . float
    (83) int -> . INTNUM
    (84) float -> . FLONUM

    (               shift and go to state 40
    ID              shift and go to state 42
    INTNUM          shift and go to state 45
    FLONUM          shift and go to state 46

    relational_expr                shift and go to state 74
    expr                           shift and go to state 75
    term                           shift and go to state 38
    factor                         shift and go to state 39
    elem                           shift and go to state 41
    int                            shift and go to state 43
    float                          shift and go to state 44

state 33

    (18) for_instruction -> FOR ID . = INTNUM : ID instructions_block
    (19) for_instruction -> FOR ID . = INTNUM : ID instruction
    (20) for_instruction -> FOR ID . = ID : ID instructions_block
    (21) for_instruction -> FOR ID . = ID : ID instruction

    =               shift and go to state 76


state 34

    (22) while_instruction -> WHILE ( . relational_expr ) instructions_block
    (23) while_instruction -> WHILE ( . relational_expr ) instruction
    (53) relational_expr -> . expr GREATEREQUAL expr
    (54) relational_expr -> . expr EQUALS expr
    (55) relational_expr -> . expr NOTEQUALS expr
    (56) relational_expr -> . expr LOWEREQUAL expr
    (57) relational_expr -> . expr < expr
    (58) relational_expr -> . expr > expr
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (69) elem -> . ID
    (70) elem -> . int
    (71) elem -> . float
    (83) int -> . INTNUM
    (84) float -> . FLONUM

    (               shift and go to state 40
    ID              shift and go to state 42
    INTNUM          shift and go to state 45
    FLONUM          shift and go to state 46

    relational_expr                shift and go to state 77
    expr                           shift and go to state 75
    term                           shift and go to state 38
    factor                         shift and go to state 39
    elem                           shift and go to state 41
    int                            shift and go to state 43
    float                          shift and go to state 44

state 35

    (27) print_instruction -> PRINT print_list . ;
    (28) print_list -> print_list . , expr
    (29) print_list -> print_list . , STRING

    ;               shift and go to state 78
    ,               shift and go to state 79


state 36

    (30) print_list -> expr .
    (45) expr -> expr . + term
    (46) expr -> expr . - term

    ;               reduce using rule 30 (print_list -> expr .)
    ,               reduce using rule 30 (print_list -> expr .)
    +               shift and go to state 80
    -               shift and go to state 81


state 37

    (31) print_list -> STRING .

    ;               reduce using rule 31 (print_list -> STRING .)
    ,               reduce using rule 31 (print_list -> STRING .)


state 38

    (47) expr -> term .
    (48) term -> term . * factor
    (49) term -> term . / factor

    +               reduce using rule 47 (expr -> term .)
    -               reduce using rule 47 (expr -> term .)
    ;               reduce using rule 47 (expr -> term .)
    ,               reduce using rule 47 (expr -> term .)
    GREATEREQUAL    reduce using rule 47 (expr -> term .)
    EQUALS          reduce using rule 47 (expr -> term .)
    NOTEQUALS       reduce using rule 47 (expr -> term .)
    LOWEREQUAL      reduce using rule 47 (expr -> term .)
    <               reduce using rule 47 (expr -> term .)
    >               reduce using rule 47 (expr -> term .)
    )               reduce using rule 47 (expr -> term .)
    *               shift and go to state 82
    /               shift and go to state 83


state 39

    (50) term -> factor .

    *               reduce using rule 50 (term -> factor .)
    /               reduce using rule 50 (term -> factor .)
    +               reduce using rule 50 (term -> factor .)
    -               reduce using rule 50 (term -> factor .)
    ;               reduce using rule 50 (term -> factor .)
    ,               reduce using rule 50 (term -> factor .)
    GREATEREQUAL    reduce using rule 50 (term -> factor .)
    EQUALS          reduce using rule 50 (term -> factor .)
    NOTEQUALS       reduce using rule 50 (term -> factor .)
    LOWEREQUAL      reduce using rule 50 (term -> factor .)
    <               reduce using rule 50 (term -> factor .)
    >               reduce using rule 50 (term -> factor .)
    )               reduce using rule 50 (term -> factor .)


state 40

    (51) factor -> ( . expr )
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (69) elem -> . ID
    (70) elem -> . int
    (71) elem -> . float
    (83) int -> . INTNUM
    (84) float -> . FLONUM

    (               shift and go to state 40
    ID              shift and go to state 42
    INTNUM          shift and go to state 45
    FLONUM          shift and go to state 46

    expr                           shift and go to state 84
    term                           shift and go to state 38
    factor                         shift and go to state 39
    elem                           shift and go to state 41
    int                            shift and go to state 43
    float                          shift and go to state 44

state 41

    (52) factor -> elem .

    *               reduce using rule 52 (factor -> elem .)
    /               reduce using rule 52 (factor -> elem .)
    +               reduce using rule 52 (factor -> elem .)
    -               reduce using rule 52 (factor -> elem .)
    ;               reduce using rule 52 (factor -> elem .)
    ,               reduce using rule 52 (factor -> elem .)
    GREATEREQUAL    reduce using rule 52 (factor -> elem .)
    EQUALS          reduce using rule 52 (factor -> elem .)
    NOTEQUALS       reduce using rule 52 (factor -> elem .)
    LOWEREQUAL      reduce using rule 52 (factor -> elem .)
    <               reduce using rule 52 (factor -> elem .)
    >               reduce using rule 52 (factor -> elem .)
    )               reduce using rule 52 (factor -> elem .)


state 42

    (69) elem -> ID .

    *               reduce using rule 69 (elem -> ID .)
    /               reduce using rule 69 (elem -> ID .)
    +               reduce using rule 69 (elem -> ID .)
    -               reduce using rule 69 (elem -> ID .)
    ;               reduce using rule 69 (elem -> ID .)
    ,               reduce using rule 69 (elem -> ID .)
    GREATEREQUAL    reduce using rule 69 (elem -> ID .)
    EQUALS          reduce using rule 69 (elem -> ID .)
    NOTEQUALS       reduce using rule 69 (elem -> ID .)
    LOWEREQUAL      reduce using rule 69 (elem -> ID .)
    <               reduce using rule 69 (elem -> ID .)
    >               reduce using rule 69 (elem -> ID .)
    )               reduce using rule 69 (elem -> ID .)
    ]               reduce using rule 69 (elem -> ID .)


state 43

    (70) elem -> int .

    *               reduce using rule 70 (elem -> int .)
    /               reduce using rule 70 (elem -> int .)
    +               reduce using rule 70 (elem -> int .)
    -               reduce using rule 70 (elem -> int .)
    ;               reduce using rule 70 (elem -> int .)
    ,               reduce using rule 70 (elem -> int .)
    GREATEREQUAL    reduce using rule 70 (elem -> int .)
    EQUALS          reduce using rule 70 (elem -> int .)
    NOTEQUALS       reduce using rule 70 (elem -> int .)
    LOWEREQUAL      reduce using rule 70 (elem -> int .)
    <               reduce using rule 70 (elem -> int .)
    >               reduce using rule 70 (elem -> int .)
    )               reduce using rule 70 (elem -> int .)
    ]               reduce using rule 70 (elem -> int .)


state 44

    (71) elem -> float .

    *               reduce using rule 71 (elem -> float .)
    /               reduce using rule 71 (elem -> float .)
    +               reduce using rule 71 (elem -> float .)
    -               reduce using rule 71 (elem -> float .)
    ;               reduce using rule 71 (elem -> float .)
    ,               reduce using rule 71 (elem -> float .)
    GREATEREQUAL    reduce using rule 71 (elem -> float .)
    EQUALS          reduce using rule 71 (elem -> float .)
    NOTEQUALS       reduce using rule 71 (elem -> float .)
    LOWEREQUAL      reduce using rule 71 (elem -> float .)
    <               reduce using rule 71 (elem -> float .)
    >               reduce using rule 71 (elem -> float .)
    )               reduce using rule 71 (elem -> float .)
    ]               reduce using rule 71 (elem -> float .)


state 45

    (83) int -> INTNUM .

    *               reduce using rule 83 (int -> INTNUM .)
    /               reduce using rule 83 (int -> INTNUM .)
    +               reduce using rule 83 (int -> INTNUM .)
    -               reduce using rule 83 (int -> INTNUM .)
    ;               reduce using rule 83 (int -> INTNUM .)
    ,               reduce using rule 83 (int -> INTNUM .)
    GREATEREQUAL    reduce using rule 83 (int -> INTNUM .)
    EQUALS          reduce using rule 83 (int -> INTNUM .)
    NOTEQUALS       reduce using rule 83 (int -> INTNUM .)
    LOWEREQUAL      reduce using rule 83 (int -> INTNUM .)
    <               reduce using rule 83 (int -> INTNUM .)
    >               reduce using rule 83 (int -> INTNUM .)
    )               reduce using rule 83 (int -> INTNUM .)
    ]               reduce using rule 83 (int -> INTNUM .)


state 46

    (84) float -> FLONUM .

    *               reduce using rule 84 (float -> FLONUM .)
    /               reduce using rule 84 (float -> FLONUM .)
    +               reduce using rule 84 (float -> FLONUM .)
    -               reduce using rule 84 (float -> FLONUM .)
    ;               reduce using rule 84 (float -> FLONUM .)
    ,               reduce using rule 84 (float -> FLONUM .)
    GREATEREQUAL    reduce using rule 84 (float -> FLONUM .)
    EQUALS          reduce using rule 84 (float -> FLONUM .)
    NOTEQUALS       reduce using rule 84 (float -> FLONUM .)
    LOWEREQUAL      reduce using rule 84 (float -> FLONUM .)
    <               reduce using rule 84 (float -> FLONUM .)
    >               reduce using rule 84 (float -> FLONUM .)
    )               reduce using rule 84 (float -> FLONUM .)
    ]               reduce using rule 84 (float -> FLONUM .)


state 47

    (24) loop_instruction -> BREAK ; .

    ID              reduce using rule 24 (loop_instruction -> BREAK ; .)
    IF              reduce using rule 24 (loop_instruction -> BREAK ; .)
    FOR             reduce using rule 24 (loop_instruction -> BREAK ; .)
    WHILE           reduce using rule 24 (loop_instruction -> BREAK ; .)
    PRINT           reduce using rule 24 (loop_instruction -> BREAK ; .)
    BREAK           reduce using rule 24 (loop_instruction -> BREAK ; .)
    CONTINUE        reduce using rule 24 (loop_instruction -> BREAK ; .)
    RETURN          reduce using rule 24 (loop_instruction -> BREAK ; .)
    {               reduce using rule 24 (loop_instruction -> BREAK ; .)
    $end            reduce using rule 24 (loop_instruction -> BREAK ; .)
    }               reduce using rule 24 (loop_instruction -> BREAK ; .)
    ELSE            reduce using rule 24 (loop_instruction -> BREAK ; .)


state 48

    (25) loop_instruction -> CONTINUE ; .

    ID              reduce using rule 25 (loop_instruction -> CONTINUE ; .)
    IF              reduce using rule 25 (loop_instruction -> CONTINUE ; .)
    FOR             reduce using rule 25 (loop_instruction -> CONTINUE ; .)
    WHILE           reduce using rule 25 (loop_instruction -> CONTINUE ; .)
    PRINT           reduce using rule 25 (loop_instruction -> CONTINUE ; .)
    BREAK           reduce using rule 25 (loop_instruction -> CONTINUE ; .)
    CONTINUE        reduce using rule 25 (loop_instruction -> CONTINUE ; .)
    RETURN          reduce using rule 25 (loop_instruction -> CONTINUE ; .)
    {               reduce using rule 25 (loop_instruction -> CONTINUE ; .)
    $end            reduce using rule 25 (loop_instruction -> CONTINUE ; .)
    }               reduce using rule 25 (loop_instruction -> CONTINUE ; .)
    ELSE            reduce using rule 25 (loop_instruction -> CONTINUE ; .)


state 49

    (26) return_instruction -> RETURN expr . ;
    (45) expr -> expr . + term
    (46) expr -> expr . - term

    ;               shift and go to state 85
    +               shift and go to state 80
    -               shift and go to state 81


state 50

    (3) instructions_block -> { instructions . }

    }               shift and go to state 86


state 51

    (38) token -> ID .
    (80) matrix_factor -> ID .
    (69) elem -> ID .

  ! reduce/reduce conflict for ; resolved using rule 38 (token -> ID .)
  ! reduce/reduce conflict for ; resolved using rule 38 (token -> ID .)
    ;               reduce using rule 38 (token -> ID .)
    DOTMUL          reduce using rule 80 (matrix_factor -> ID .)
    DOTDIV          reduce using rule 80 (matrix_factor -> ID .)
    DOTADD          reduce using rule 80 (matrix_factor -> ID .)
    DOTSUB          reduce using rule 80 (matrix_factor -> ID .)
    '               reduce using rule 80 (matrix_factor -> ID .)
    *               reduce using rule 69 (elem -> ID .)
    /               reduce using rule 69 (elem -> ID .)
    +               reduce using rule 69 (elem -> ID .)
    -               reduce using rule 69 (elem -> ID .)

  ! ;               [ reduce using rule 80 (matrix_factor -> ID .) ]
  ! ;               [ reduce using rule 69 (elem -> ID .) ]


state 52

    (32) assignment -> ID = token .

    ;               reduce using rule 32 (assignment -> ID = token .)


state 53

    (39) token -> int .
    (70) elem -> int .

  ! reduce/reduce conflict for ; resolved using rule 39 (token -> int .)
    ;               reduce using rule 39 (token -> int .)
    *               reduce using rule 70 (elem -> int .)
    /               reduce using rule 70 (elem -> int .)
    +               reduce using rule 70 (elem -> int .)
    -               reduce using rule 70 (elem -> int .)

  ! ;               [ reduce using rule 70 (elem -> int .) ]


state 54

    (40) token -> float .
    (71) elem -> float .

  ! reduce/reduce conflict for ; resolved using rule 40 (token -> float .)
    ;               reduce using rule 40 (token -> float .)
    *               reduce using rule 71 (elem -> float .)
    /               reduce using rule 71 (elem -> float .)
    +               reduce using rule 71 (elem -> float .)
    -               reduce using rule 71 (elem -> float .)

  ! ;               [ reduce using rule 71 (elem -> float .) ]


state 55

    (41) token -> matrix .
    (79) matrix_factor -> matrix .

  ! reduce/reduce conflict for ; resolved using rule 41 (token -> matrix .)
    ;               reduce using rule 41 (token -> matrix .)
    DOTMUL          reduce using rule 79 (matrix_factor -> matrix .)
    DOTDIV          reduce using rule 79 (matrix_factor -> matrix .)
    DOTADD          reduce using rule 79 (matrix_factor -> matrix .)
    DOTSUB          reduce using rule 79 (matrix_factor -> matrix .)
    '               reduce using rule 79 (matrix_factor -> matrix .)

  ! ;               [ reduce using rule 79 (matrix_factor -> matrix .) ]


state 56

    (42) token -> expr .
    (45) expr -> expr . + term
    (46) expr -> expr . - term

    ;               reduce using rule 42 (token -> expr .)
    +               shift and go to state 80
    -               shift and go to state 81


state 57

    (43) token -> matrix_expr .
    (72) matrix_expr -> matrix_expr . DOTADD matrix_term
    (73) matrix_expr -> matrix_expr . DOTSUB matrix_term
    (82) unary_expr -> matrix_expr . '

    ;               reduce using rule 43 (token -> matrix_expr .)
    DOTADD          shift and go to state 87
    DOTSUB          shift and go to state 88
    '               shift and go to state 89


state 58

    (44) token -> unary_expr .

    ;               reduce using rule 44 (token -> unary_expr .)


state 59

    (60) matrix -> vector .

    ;               reduce using rule 60 (matrix -> vector .)
    DOTMUL          reduce using rule 60 (matrix -> vector .)
    DOTDIV          reduce using rule 60 (matrix -> vector .)
    DOTADD          reduce using rule 60 (matrix -> vector .)
    DOTSUB          reduce using rule 60 (matrix -> vector .)
    '               reduce using rule 60 (matrix -> vector .)
    )               reduce using rule 60 (matrix -> vector .)


state 60

    (61) matrix -> ONES . ( int )

    (               shift and go to state 90


state 61

    (51) factor -> ( . expr )
    (78) matrix_factor -> ( . matrix_expr )
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (72) matrix_expr -> . matrix_expr DOTADD matrix_term
    (73) matrix_expr -> . matrix_expr DOTSUB matrix_term
    (74) matrix_expr -> . matrix_term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (75) matrix_term -> . matrix_term DOTMUL matrix_factor
    (76) matrix_term -> . matrix_term DOTDIV matrix_factor
    (77) matrix_term -> . matrix_factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (78) matrix_factor -> . ( matrix_expr )
    (79) matrix_factor -> . matrix
    (80) matrix_factor -> . ID
    (69) elem -> . ID
    (70) elem -> . int
    (71) elem -> . float
    (60) matrix -> . vector
    (61) matrix -> . ONES ( int )
    (62) matrix -> . ZEROS ( int )
    (63) matrix -> . EYE ( int )
    (83) int -> . INTNUM
    (84) float -> . FLONUM
    (64) vector -> . [ outerlist ]

    (               shift and go to state 61
    ID              shift and go to state 93
    ONES            shift and go to state 60
    ZEROS           shift and go to state 62
    EYE             shift and go to state 63
    INTNUM          shift and go to state 45
    FLONUM          shift and go to state 46
    [               shift and go to state 66

    expr                           shift and go to state 84
    matrix_expr                    shift and go to state 91
    term                           shift and go to state 38
    matrix_term                    shift and go to state 65
    factor                         shift and go to state 39
    matrix_factor                  shift and go to state 67
    elem                           shift and go to state 41
    matrix                         shift and go to state 92
    int                            shift and go to state 43
    float                          shift and go to state 44
    vector                         shift and go to state 59

state 62

    (62) matrix -> ZEROS . ( int )

    (               shift and go to state 94


state 63

    (63) matrix -> EYE . ( int )

    (               shift and go to state 95


state 64

    (81) unary_expr -> - . expr
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (69) elem -> . ID
    (70) elem -> . int
    (71) elem -> . float
    (83) int -> . INTNUM
    (84) float -> . FLONUM

    (               shift and go to state 40
    ID              shift and go to state 42
    INTNUM          shift and go to state 45
    FLONUM          shift and go to state 46

    expr                           shift and go to state 96
    term                           shift and go to state 38
    factor                         shift and go to state 39
    elem                           shift and go to state 41
    int                            shift and go to state 43
    float                          shift and go to state 44

state 65

    (74) matrix_expr -> matrix_term .
    (75) matrix_term -> matrix_term . DOTMUL matrix_factor
    (76) matrix_term -> matrix_term . DOTDIV matrix_factor

    DOTADD          reduce using rule 74 (matrix_expr -> matrix_term .)
    DOTSUB          reduce using rule 74 (matrix_expr -> matrix_term .)
    '               reduce using rule 74 (matrix_expr -> matrix_term .)
    ;               reduce using rule 74 (matrix_expr -> matrix_term .)
    )               reduce using rule 74 (matrix_expr -> matrix_term .)
    DOTMUL          shift and go to state 97
    DOTDIV          shift and go to state 98


state 66

    (64) vector -> [ . outerlist ]
    (65) outerlist -> . outerlist , [ innerlist ]
    (66) outerlist -> . [ innerlist ]

    [               shift and go to state 99

    outerlist                      shift and go to state 100

state 67

    (77) matrix_term -> matrix_factor .

    DOTMUL          reduce using rule 77 (matrix_term -> matrix_factor .)
    DOTDIV          reduce using rule 77 (matrix_term -> matrix_factor .)
    DOTADD          reduce using rule 77 (matrix_term -> matrix_factor .)
    DOTSUB          reduce using rule 77 (matrix_term -> matrix_factor .)
    '               reduce using rule 77 (matrix_term -> matrix_factor .)
    ;               reduce using rule 77 (matrix_term -> matrix_factor .)
    )               reduce using rule 77 (matrix_term -> matrix_factor .)


state 68

    (33) assignment -> ID ADDASSIGN token .

    ;               reduce using rule 33 (assignment -> ID ADDASSIGN token .)


state 69

    (34) assignment -> ID SUBASSIGN token .

    ;               reduce using rule 34 (assignment -> ID SUBASSIGN token .)


state 70

    (35) assignment -> ID MULASSIGN token .

    ;               reduce using rule 35 (assignment -> ID MULASSIGN token .)


state 71

    (36) assignment -> ID DIVASSIGN token .

    ;               reduce using rule 36 (assignment -> ID DIVASSIGN token .)


state 72

    (59) MID -> ID [ INTNUM . , INTNUM ]

    ,               shift and go to state 101


state 73

    (37) assignment -> MID = elem .

    ;               reduce using rule 37 (assignment -> MID = elem .)


state 74

    (14) if_instruction -> IF ( relational_expr . ) instructions_block
    (15) if_instruction -> IF ( relational_expr . ) instruction
    (16) if_instruction -> IF ( relational_expr . ) instructions_block ELSE instruction
    (17) if_instruction -> IF ( relational_expr . ) instruction ELSE instruction

    )               shift and go to state 102


state 75

    (53) relational_expr -> expr . GREATEREQUAL expr
    (54) relational_expr -> expr . EQUALS expr
    (55) relational_expr -> expr . NOTEQUALS expr
    (56) relational_expr -> expr . LOWEREQUAL expr
    (57) relational_expr -> expr . < expr
    (58) relational_expr -> expr . > expr
    (45) expr -> expr . + term
    (46) expr -> expr . - term

    GREATEREQUAL    shift and go to state 103
    EQUALS          shift and go to state 104
    NOTEQUALS       shift and go to state 105
    LOWEREQUAL      shift and go to state 106
    <               shift and go to state 107
    >               shift and go to state 108
    +               shift and go to state 80
    -               shift and go to state 81


state 76

    (18) for_instruction -> FOR ID = . INTNUM : ID instructions_block
    (19) for_instruction -> FOR ID = . INTNUM : ID instruction
    (20) for_instruction -> FOR ID = . ID : ID instructions_block
    (21) for_instruction -> FOR ID = . ID : ID instruction

    INTNUM          shift and go to state 110
    ID              shift and go to state 109


state 77

    (22) while_instruction -> WHILE ( relational_expr . ) instructions_block
    (23) while_instruction -> WHILE ( relational_expr . ) instruction

    )               shift and go to state 111


state 78

    (27) print_instruction -> PRINT print_list ; .

    ID              reduce using rule 27 (print_instruction -> PRINT print_list ; .)
    IF              reduce using rule 27 (print_instruction -> PRINT print_list ; .)
    FOR             reduce using rule 27 (print_instruction -> PRINT print_list ; .)
    WHILE           reduce using rule 27 (print_instruction -> PRINT print_list ; .)
    PRINT           reduce using rule 27 (print_instruction -> PRINT print_list ; .)
    BREAK           reduce using rule 27 (print_instruction -> PRINT print_list ; .)
    CONTINUE        reduce using rule 27 (print_instruction -> PRINT print_list ; .)
    RETURN          reduce using rule 27 (print_instruction -> PRINT print_list ; .)
    {               reduce using rule 27 (print_instruction -> PRINT print_list ; .)
    $end            reduce using rule 27 (print_instruction -> PRINT print_list ; .)
    }               reduce using rule 27 (print_instruction -> PRINT print_list ; .)
    ELSE            reduce using rule 27 (print_instruction -> PRINT print_list ; .)


state 79

    (28) print_list -> print_list , . expr
    (29) print_list -> print_list , . STRING
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (69) elem -> . ID
    (70) elem -> . int
    (71) elem -> . float
    (83) int -> . INTNUM
    (84) float -> . FLONUM

    STRING          shift and go to state 113
    (               shift and go to state 40
    ID              shift and go to state 42
    INTNUM          shift and go to state 45
    FLONUM          shift and go to state 46

    expr                           shift and go to state 112
    term                           shift and go to state 38
    factor                         shift and go to state 39
    elem                           shift and go to state 41
    int                            shift and go to state 43
    float                          shift and go to state 44

state 80

    (45) expr -> expr + . term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (69) elem -> . ID
    (70) elem -> . int
    (71) elem -> . float
    (83) int -> . INTNUM
    (84) float -> . FLONUM

    (               shift and go to state 40
    ID              shift and go to state 42
    INTNUM          shift and go to state 45
    FLONUM          shift and go to state 46

    term                           shift and go to state 114
    factor                         shift and go to state 39
    elem                           shift and go to state 41
    int                            shift and go to state 43
    float                          shift and go to state 44

state 81

    (46) expr -> expr - . term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (69) elem -> . ID
    (70) elem -> . int
    (71) elem -> . float
    (83) int -> . INTNUM
    (84) float -> . FLONUM

    (               shift and go to state 40
    ID              shift and go to state 42
    INTNUM          shift and go to state 45
    FLONUM          shift and go to state 46

    term                           shift and go to state 115
    factor                         shift and go to state 39
    elem                           shift and go to state 41
    int                            shift and go to state 43
    float                          shift and go to state 44

state 82

    (48) term -> term * . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (69) elem -> . ID
    (70) elem -> . int
    (71) elem -> . float
    (83) int -> . INTNUM
    (84) float -> . FLONUM

    (               shift and go to state 40
    ID              shift and go to state 42
    INTNUM          shift and go to state 45
    FLONUM          shift and go to state 46

    factor                         shift and go to state 116
    elem                           shift and go to state 41
    int                            shift and go to state 43
    float                          shift and go to state 44

state 83

    (49) term -> term / . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (69) elem -> . ID
    (70) elem -> . int
    (71) elem -> . float
    (83) int -> . INTNUM
    (84) float -> . FLONUM

    (               shift and go to state 40
    ID              shift and go to state 42
    INTNUM          shift and go to state 45
    FLONUM          shift and go to state 46

    factor                         shift and go to state 117
    elem                           shift and go to state 41
    int                            shift and go to state 43
    float                          shift and go to state 44

state 84

    (51) factor -> ( expr . )
    (45) expr -> expr . + term
    (46) expr -> expr . - term

    )               shift and go to state 118
    +               shift and go to state 80
    -               shift and go to state 81


state 85

    (26) return_instruction -> RETURN expr ; .

    ID              reduce using rule 26 (return_instruction -> RETURN expr ; .)
    IF              reduce using rule 26 (return_instruction -> RETURN expr ; .)
    FOR             reduce using rule 26 (return_instruction -> RETURN expr ; .)
    WHILE           reduce using rule 26 (return_instruction -> RETURN expr ; .)
    PRINT           reduce using rule 26 (return_instruction -> RETURN expr ; .)
    BREAK           reduce using rule 26 (return_instruction -> RETURN expr ; .)
    CONTINUE        reduce using rule 26 (return_instruction -> RETURN expr ; .)
    RETURN          reduce using rule 26 (return_instruction -> RETURN expr ; .)
    {               reduce using rule 26 (return_instruction -> RETURN expr ; .)
    $end            reduce using rule 26 (return_instruction -> RETURN expr ; .)
    }               reduce using rule 26 (return_instruction -> RETURN expr ; .)
    ELSE            reduce using rule 26 (return_instruction -> RETURN expr ; .)


state 86

    (3) instructions_block -> { instructions } .

    ID              reduce using rule 3 (instructions_block -> { instructions } .)
    IF              reduce using rule 3 (instructions_block -> { instructions } .)
    FOR             reduce using rule 3 (instructions_block -> { instructions } .)
    WHILE           reduce using rule 3 (instructions_block -> { instructions } .)
    PRINT           reduce using rule 3 (instructions_block -> { instructions } .)
    BREAK           reduce using rule 3 (instructions_block -> { instructions } .)
    CONTINUE        reduce using rule 3 (instructions_block -> { instructions } .)
    RETURN          reduce using rule 3 (instructions_block -> { instructions } .)
    {               reduce using rule 3 (instructions_block -> { instructions } .)
    $end            reduce using rule 3 (instructions_block -> { instructions } .)
    }               reduce using rule 3 (instructions_block -> { instructions } .)
    ELSE            reduce using rule 3 (instructions_block -> { instructions } .)


state 87

    (72) matrix_expr -> matrix_expr DOTADD . matrix_term
    (75) matrix_term -> . matrix_term DOTMUL matrix_factor
    (76) matrix_term -> . matrix_term DOTDIV matrix_factor
    (77) matrix_term -> . matrix_factor
    (78) matrix_factor -> . ( matrix_expr )
    (79) matrix_factor -> . matrix
    (80) matrix_factor -> . ID
    (60) matrix -> . vector
    (61) matrix -> . ONES ( int )
    (62) matrix -> . ZEROS ( int )
    (63) matrix -> . EYE ( int )
    (64) vector -> . [ outerlist ]

    (               shift and go to state 120
    ID              shift and go to state 121
    ONES            shift and go to state 60
    ZEROS           shift and go to state 62
    EYE             shift and go to state 63
    [               shift and go to state 66

    matrix_term                    shift and go to state 119
    matrix_factor                  shift and go to state 67
    matrix                         shift and go to state 92
    vector                         shift and go to state 59

state 88

    (73) matrix_expr -> matrix_expr DOTSUB . matrix_term
    (75) matrix_term -> . matrix_term DOTMUL matrix_factor
    (76) matrix_term -> . matrix_term DOTDIV matrix_factor
    (77) matrix_term -> . matrix_factor
    (78) matrix_factor -> . ( matrix_expr )
    (79) matrix_factor -> . matrix
    (80) matrix_factor -> . ID
    (60) matrix -> . vector
    (61) matrix -> . ONES ( int )
    (62) matrix -> . ZEROS ( int )
    (63) matrix -> . EYE ( int )
    (64) vector -> . [ outerlist ]

    (               shift and go to state 120
    ID              shift and go to state 121
    ONES            shift and go to state 60
    ZEROS           shift and go to state 62
    EYE             shift and go to state 63
    [               shift and go to state 66

    matrix_term                    shift and go to state 122
    matrix_factor                  shift and go to state 67
    matrix                         shift and go to state 92
    vector                         shift and go to state 59

state 89

    (82) unary_expr -> matrix_expr ' .

    ;               reduce using rule 82 (unary_expr -> matrix_expr ' .)


state 90

    (61) matrix -> ONES ( . int )
    (83) int -> . INTNUM

    INTNUM          shift and go to state 45

    int                            shift and go to state 123

state 91

    (78) matrix_factor -> ( matrix_expr . )
    (72) matrix_expr -> matrix_expr . DOTADD matrix_term
    (73) matrix_expr -> matrix_expr . DOTSUB matrix_term

    )               shift and go to state 124
    DOTADD          shift and go to state 87
    DOTSUB          shift and go to state 88


state 92

    (79) matrix_factor -> matrix .

    DOTMUL          reduce using rule 79 (matrix_factor -> matrix .)
    DOTDIV          reduce using rule 79 (matrix_factor -> matrix .)
    )               reduce using rule 79 (matrix_factor -> matrix .)
    DOTADD          reduce using rule 79 (matrix_factor -> matrix .)
    DOTSUB          reduce using rule 79 (matrix_factor -> matrix .)
    '               reduce using rule 79 (matrix_factor -> matrix .)
    ;               reduce using rule 79 (matrix_factor -> matrix .)


state 93

    (80) matrix_factor -> ID .
    (69) elem -> ID .

  ! reduce/reduce conflict for ) resolved using rule 69 (elem -> ID .)
    DOTMUL          reduce using rule 80 (matrix_factor -> ID .)
    DOTDIV          reduce using rule 80 (matrix_factor -> ID .)
    DOTADD          reduce using rule 80 (matrix_factor -> ID .)
    DOTSUB          reduce using rule 80 (matrix_factor -> ID .)
    *               reduce using rule 69 (elem -> ID .)
    /               reduce using rule 69 (elem -> ID .)
    )               reduce using rule 69 (elem -> ID .)
    +               reduce using rule 69 (elem -> ID .)
    -               reduce using rule 69 (elem -> ID .)

  ! )               [ reduce using rule 80 (matrix_factor -> ID .) ]


state 94

    (62) matrix -> ZEROS ( . int )
    (83) int -> . INTNUM

    INTNUM          shift and go to state 45

    int                            shift and go to state 125

state 95

    (63) matrix -> EYE ( . int )
    (83) int -> . INTNUM

    INTNUM          shift and go to state 45

    int                            shift and go to state 126

state 96

    (81) unary_expr -> - expr .
    (45) expr -> expr . + term
    (46) expr -> expr . - term

    ;               reduce using rule 81 (unary_expr -> - expr .)
    +               shift and go to state 80
    -               shift and go to state 81


state 97

    (75) matrix_term -> matrix_term DOTMUL . matrix_factor
    (78) matrix_factor -> . ( matrix_expr )
    (79) matrix_factor -> . matrix
    (80) matrix_factor -> . ID
    (60) matrix -> . vector
    (61) matrix -> . ONES ( int )
    (62) matrix -> . ZEROS ( int )
    (63) matrix -> . EYE ( int )
    (64) vector -> . [ outerlist ]

    (               shift and go to state 120
    ID              shift and go to state 121
    ONES            shift and go to state 60
    ZEROS           shift and go to state 62
    EYE             shift and go to state 63
    [               shift and go to state 66

    matrix_factor                  shift and go to state 127
    matrix                         shift and go to state 92
    vector                         shift and go to state 59

state 98

    (76) matrix_term -> matrix_term DOTDIV . matrix_factor
    (78) matrix_factor -> . ( matrix_expr )
    (79) matrix_factor -> . matrix
    (80) matrix_factor -> . ID
    (60) matrix -> . vector
    (61) matrix -> . ONES ( int )
    (62) matrix -> . ZEROS ( int )
    (63) matrix -> . EYE ( int )
    (64) vector -> . [ outerlist ]

    (               shift and go to state 120
    ID              shift and go to state 121
    ONES            shift and go to state 60
    ZEROS           shift and go to state 62
    EYE             shift and go to state 63
    [               shift and go to state 66

    matrix_factor                  shift and go to state 128
    matrix                         shift and go to state 92
    vector                         shift and go to state 59

state 99

    (66) outerlist -> [ . innerlist ]
    (67) innerlist -> . innerlist , elem
    (68) innerlist -> . elem
    (69) elem -> . ID
    (70) elem -> . int
    (71) elem -> . float
    (83) int -> . INTNUM
    (84) float -> . FLONUM

    ID              shift and go to state 42
    INTNUM          shift and go to state 45
    FLONUM          shift and go to state 46

    innerlist                      shift and go to state 129
    elem                           shift and go to state 130
    int                            shift and go to state 43
    float                          shift and go to state 44

state 100

    (64) vector -> [ outerlist . ]
    (65) outerlist -> outerlist . , [ innerlist ]

    ]               shift and go to state 131
    ,               shift and go to state 132


state 101

    (59) MID -> ID [ INTNUM , . INTNUM ]

    INTNUM          shift and go to state 133


state 102

    (14) if_instruction -> IF ( relational_expr ) . instructions_block
    (15) if_instruction -> IF ( relational_expr ) . instruction
    (16) if_instruction -> IF ( relational_expr ) . instructions_block ELSE instruction
    (17) if_instruction -> IF ( relational_expr ) . instruction ELSE instruction
    (3) instructions_block -> . { instructions }
    (6) instruction -> . assignment ;
    (7) instruction -> . if_instruction
    (8) instruction -> . for_instruction
    (9) instruction -> . while_instruction
    (10) instruction -> . print_instruction
    (11) instruction -> . loop_instruction
    (12) instruction -> . return_instruction
    (13) instruction -> . instructions_block
    (32) assignment -> . ID = token
    (33) assignment -> . ID ADDASSIGN token
    (34) assignment -> . ID SUBASSIGN token
    (35) assignment -> . ID MULASSIGN token
    (36) assignment -> . ID DIVASSIGN token
    (37) assignment -> . MID = elem
    (14) if_instruction -> . IF ( relational_expr ) instructions_block
    (15) if_instruction -> . IF ( relational_expr ) instruction
    (16) if_instruction -> . IF ( relational_expr ) instructions_block ELSE instruction
    (17) if_instruction -> . IF ( relational_expr ) instruction ELSE instruction
    (18) for_instruction -> . FOR ID = INTNUM : ID instructions_block
    (19) for_instruction -> . FOR ID = INTNUM : ID instruction
    (20) for_instruction -> . FOR ID = ID : ID instructions_block
    (21) for_instruction -> . FOR ID = ID : ID instruction
    (22) while_instruction -> . WHILE ( relational_expr ) instructions_block
    (23) while_instruction -> . WHILE ( relational_expr ) instruction
    (27) print_instruction -> . PRINT print_list ;
    (24) loop_instruction -> . BREAK ;
    (25) loop_instruction -> . CONTINUE ;
    (26) return_instruction -> . RETURN expr ;
    (59) MID -> . ID [ INTNUM , INTNUM ]

    {               shift and go to state 22
    ID              shift and go to state 13
    IF              shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    PRINT           shift and go to state 18
    BREAK           shift and go to state 19
    CONTINUE        shift and go to state 20
    RETURN          shift and go to state 21

    instructions_block             shift and go to state 134
    instruction                    shift and go to state 135
    assignment                     shift and go to state 5
    if_instruction                 shift and go to state 6
    for_instruction                shift and go to state 7
    while_instruction              shift and go to state 8
    print_instruction              shift and go to state 9
    loop_instruction               shift and go to state 10
    return_instruction             shift and go to state 11
    MID                            shift and go to state 14

state 103

    (53) relational_expr -> expr GREATEREQUAL . expr
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (69) elem -> . ID
    (70) elem -> . int
    (71) elem -> . float
    (83) int -> . INTNUM
    (84) float -> . FLONUM

    (               shift and go to state 40
    ID              shift and go to state 42
    INTNUM          shift and go to state 45
    FLONUM          shift and go to state 46

    expr                           shift and go to state 136
    term                           shift and go to state 38
    factor                         shift and go to state 39
    elem                           shift and go to state 41
    int                            shift and go to state 43
    float                          shift and go to state 44

state 104

    (54) relational_expr -> expr EQUALS . expr
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (69) elem -> . ID
    (70) elem -> . int
    (71) elem -> . float
    (83) int -> . INTNUM
    (84) float -> . FLONUM

    (               shift and go to state 40
    ID              shift and go to state 42
    INTNUM          shift and go to state 45
    FLONUM          shift and go to state 46

    expr                           shift and go to state 137
    term                           shift and go to state 38
    factor                         shift and go to state 39
    elem                           shift and go to state 41
    int                            shift and go to state 43
    float                          shift and go to state 44

state 105

    (55) relational_expr -> expr NOTEQUALS . expr
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (69) elem -> . ID
    (70) elem -> . int
    (71) elem -> . float
    (83) int -> . INTNUM
    (84) float -> . FLONUM

    (               shift and go to state 40
    ID              shift and go to state 42
    INTNUM          shift and go to state 45
    FLONUM          shift and go to state 46

    expr                           shift and go to state 138
    term                           shift and go to state 38
    factor                         shift and go to state 39
    elem                           shift and go to state 41
    int                            shift and go to state 43
    float                          shift and go to state 44

state 106

    (56) relational_expr -> expr LOWEREQUAL . expr
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (69) elem -> . ID
    (70) elem -> . int
    (71) elem -> . float
    (83) int -> . INTNUM
    (84) float -> . FLONUM

    (               shift and go to state 40
    ID              shift and go to state 42
    INTNUM          shift and go to state 45
    FLONUM          shift and go to state 46

    expr                           shift and go to state 139
    term                           shift and go to state 38
    factor                         shift and go to state 39
    elem                           shift and go to state 41
    int                            shift and go to state 43
    float                          shift and go to state 44

state 107

    (57) relational_expr -> expr < . expr
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (69) elem -> . ID
    (70) elem -> . int
    (71) elem -> . float
    (83) int -> . INTNUM
    (84) float -> . FLONUM

    (               shift and go to state 40
    ID              shift and go to state 42
    INTNUM          shift and go to state 45
    FLONUM          shift and go to state 46

    expr                           shift and go to state 140
    term                           shift and go to state 38
    factor                         shift and go to state 39
    elem                           shift and go to state 41
    int                            shift and go to state 43
    float                          shift and go to state 44

state 108

    (58) relational_expr -> expr > . expr
    (45) expr -> . expr + term
    (46) expr -> . expr - term
    (47) expr -> . term
    (48) term -> . term * factor
    (49) term -> . term / factor
    (50) term -> . factor
    (51) factor -> . ( expr )
    (52) factor -> . elem
    (69) elem -> . ID
    (70) elem -> . int
    (71) elem -> . float
    (83) int -> . INTNUM
    (84) float -> . FLONUM

    (               shift and go to state 40
    ID              shift and go to state 42
    INTNUM          shift and go to state 45
    FLONUM          shift and go to state 46

    expr                           shift and go to state 141
    term                           shift and go to state 38
    factor                         shift and go to state 39
    elem                           shift and go to state 41
    int                            shift and go to state 43
    float                          shift and go to state 44

state 109

    (20) for_instruction -> FOR ID = ID . : ID instructions_block
    (21) for_instruction -> FOR ID = ID . : ID instruction

    :               shift and go to state 142


state 110

    (18) for_instruction -> FOR ID = INTNUM . : ID instructions_block
    (19) for_instruction -> FOR ID = INTNUM . : ID instruction

    :               shift and go to state 143


state 111

    (22) while_instruction -> WHILE ( relational_expr ) . instructions_block
    (23) while_instruction -> WHILE ( relational_expr ) . instruction
    (3) instructions_block -> . { instructions }
    (6) instruction -> . assignment ;
    (7) instruction -> . if_instruction
    (8) instruction -> . for_instruction
    (9) instruction -> . while_instruction
    (10) instruction -> . print_instruction
    (11) instruction -> . loop_instruction
    (12) instruction -> . return_instruction
    (13) instruction -> . instructions_block
    (32) assignment -> . ID = token
    (33) assignment -> . ID ADDASSIGN token
    (34) assignment -> . ID SUBASSIGN token
    (35) assignment -> . ID MULASSIGN token
    (36) assignment -> . ID DIVASSIGN token
    (37) assignment -> . MID = elem
    (14) if_instruction -> . IF ( relational_expr ) instructions_block
    (15) if_instruction -> . IF ( relational_expr ) instruction
    (16) if_instruction -> . IF ( relational_expr ) instructions_block ELSE instruction
    (17) if_instruction -> . IF ( relational_expr ) instruction ELSE instruction
    (18) for_instruction -> . FOR ID = INTNUM : ID instructions_block
    (19) for_instruction -> . FOR ID = INTNUM : ID instruction
    (20) for_instruction -> . FOR ID = ID : ID instructions_block
    (21) for_instruction -> . FOR ID = ID : ID instruction
    (22) while_instruction -> . WHILE ( relational_expr ) instructions_block
    (23) while_instruction -> . WHILE ( relational_expr ) instruction
    (27) print_instruction -> . PRINT print_list ;
    (24) loop_instruction -> . BREAK ;
    (25) loop_instruction -> . CONTINUE ;
    (26) return_instruction -> . RETURN expr ;
    (59) MID -> . ID [ INTNUM , INTNUM ]

    {               shift and go to state 22
    ID              shift and go to state 13
    IF              shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    PRINT           shift and go to state 18
    BREAK           shift and go to state 19
    CONTINUE        shift and go to state 20
    RETURN          shift and go to state 21

    instructions_block             shift and go to state 144
    instruction                    shift and go to state 145
    assignment                     shift and go to state 5
    if_instruction                 shift and go to state 6
    for_instruction                shift and go to state 7
    while_instruction              shift and go to state 8
    print_instruction              shift and go to state 9
    loop_instruction               shift and go to state 10
    return_instruction             shift and go to state 11
    MID                            shift and go to state 14

state 112

    (28) print_list -> print_list , expr .
    (45) expr -> expr . + term
    (46) expr -> expr . - term

    ;               reduce using rule 28 (print_list -> print_list , expr .)
    ,               reduce using rule 28 (print_list -> print_list , expr .)
    +               shift and go to state 80
    -               shift and go to state 81


state 113

    (29) print_list -> print_list , STRING .

    ;               reduce using rule 29 (print_list -> print_list , STRING .)
    ,               reduce using rule 29 (print_list -> print_list , STRING .)


state 114

    (45) expr -> expr + term .
    (48) term -> term . * factor
    (49) term -> term . / factor

    +               reduce using rule 45 (expr -> expr + term .)
    -               reduce using rule 45 (expr -> expr + term .)
    ;               reduce using rule 45 (expr -> expr + term .)
    ,               reduce using rule 45 (expr -> expr + term .)
    GREATEREQUAL    reduce using rule 45 (expr -> expr + term .)
    EQUALS          reduce using rule 45 (expr -> expr + term .)
    NOTEQUALS       reduce using rule 45 (expr -> expr + term .)
    LOWEREQUAL      reduce using rule 45 (expr -> expr + term .)
    <               reduce using rule 45 (expr -> expr + term .)
    >               reduce using rule 45 (expr -> expr + term .)
    )               reduce using rule 45 (expr -> expr + term .)
    *               shift and go to state 82
    /               shift and go to state 83


state 115

    (46) expr -> expr - term .
    (48) term -> term . * factor
    (49) term -> term . / factor

    +               reduce using rule 46 (expr -> expr - term .)
    -               reduce using rule 46 (expr -> expr - term .)
    ;               reduce using rule 46 (expr -> expr - term .)
    ,               reduce using rule 46 (expr -> expr - term .)
    GREATEREQUAL    reduce using rule 46 (expr -> expr - term .)
    EQUALS          reduce using rule 46 (expr -> expr - term .)
    NOTEQUALS       reduce using rule 46 (expr -> expr - term .)
    LOWEREQUAL      reduce using rule 46 (expr -> expr - term .)
    <               reduce using rule 46 (expr -> expr - term .)
    >               reduce using rule 46 (expr -> expr - term .)
    )               reduce using rule 46 (expr -> expr - term .)
    *               shift and go to state 82
    /               shift and go to state 83


state 116

    (48) term -> term * factor .

    *               reduce using rule 48 (term -> term * factor .)
    /               reduce using rule 48 (term -> term * factor .)
    +               reduce using rule 48 (term -> term * factor .)
    -               reduce using rule 48 (term -> term * factor .)
    ;               reduce using rule 48 (term -> term * factor .)
    ,               reduce using rule 48 (term -> term * factor .)
    GREATEREQUAL    reduce using rule 48 (term -> term * factor .)
    EQUALS          reduce using rule 48 (term -> term * factor .)
    NOTEQUALS       reduce using rule 48 (term -> term * factor .)
    LOWEREQUAL      reduce using rule 48 (term -> term * factor .)
    <               reduce using rule 48 (term -> term * factor .)
    >               reduce using rule 48 (term -> term * factor .)
    )               reduce using rule 48 (term -> term * factor .)


state 117

    (49) term -> term / factor .

    *               reduce using rule 49 (term -> term / factor .)
    /               reduce using rule 49 (term -> term / factor .)
    +               reduce using rule 49 (term -> term / factor .)
    -               reduce using rule 49 (term -> term / factor .)
    ;               reduce using rule 49 (term -> term / factor .)
    ,               reduce using rule 49 (term -> term / factor .)
    GREATEREQUAL    reduce using rule 49 (term -> term / factor .)
    EQUALS          reduce using rule 49 (term -> term / factor .)
    NOTEQUALS       reduce using rule 49 (term -> term / factor .)
    LOWEREQUAL      reduce using rule 49 (term -> term / factor .)
    <               reduce using rule 49 (term -> term / factor .)
    >               reduce using rule 49 (term -> term / factor .)
    )               reduce using rule 49 (term -> term / factor .)


state 118

    (51) factor -> ( expr ) .

    *               reduce using rule 51 (factor -> ( expr ) .)
    /               reduce using rule 51 (factor -> ( expr ) .)
    +               reduce using rule 51 (factor -> ( expr ) .)
    -               reduce using rule 51 (factor -> ( expr ) .)
    ;               reduce using rule 51 (factor -> ( expr ) .)
    ,               reduce using rule 51 (factor -> ( expr ) .)
    GREATEREQUAL    reduce using rule 51 (factor -> ( expr ) .)
    EQUALS          reduce using rule 51 (factor -> ( expr ) .)
    NOTEQUALS       reduce using rule 51 (factor -> ( expr ) .)
    LOWEREQUAL      reduce using rule 51 (factor -> ( expr ) .)
    <               reduce using rule 51 (factor -> ( expr ) .)
    >               reduce using rule 51 (factor -> ( expr ) .)
    )               reduce using rule 51 (factor -> ( expr ) .)


state 119

    (72) matrix_expr -> matrix_expr DOTADD matrix_term .
    (75) matrix_term -> matrix_term . DOTMUL matrix_factor
    (76) matrix_term -> matrix_term . DOTDIV matrix_factor

    DOTADD          reduce using rule 72 (matrix_expr -> matrix_expr DOTADD matrix_term .)
    DOTSUB          reduce using rule 72 (matrix_expr -> matrix_expr DOTADD matrix_term .)
    '               reduce using rule 72 (matrix_expr -> matrix_expr DOTADD matrix_term .)
    ;               reduce using rule 72 (matrix_expr -> matrix_expr DOTADD matrix_term .)
    )               reduce using rule 72 (matrix_expr -> matrix_expr DOTADD matrix_term .)
    DOTMUL          shift and go to state 97
    DOTDIV          shift and go to state 98


state 120

    (78) matrix_factor -> ( . matrix_expr )
    (72) matrix_expr -> . matrix_expr DOTADD matrix_term
    (73) matrix_expr -> . matrix_expr DOTSUB matrix_term
    (74) matrix_expr -> . matrix_term
    (75) matrix_term -> . matrix_term DOTMUL matrix_factor
    (76) matrix_term -> . matrix_term DOTDIV matrix_factor
    (77) matrix_term -> . matrix_factor
    (78) matrix_factor -> . ( matrix_expr )
    (79) matrix_factor -> . matrix
    (80) matrix_factor -> . ID
    (60) matrix -> . vector
    (61) matrix -> . ONES ( int )
    (62) matrix -> . ZEROS ( int )
    (63) matrix -> . EYE ( int )
    (64) vector -> . [ outerlist ]

    (               shift and go to state 120
    ID              shift and go to state 121
    ONES            shift and go to state 60
    ZEROS           shift and go to state 62
    EYE             shift and go to state 63
    [               shift and go to state 66

    matrix_expr                    shift and go to state 91
    matrix_term                    shift and go to state 65
    matrix_factor                  shift and go to state 67
    matrix                         shift and go to state 92
    vector                         shift and go to state 59

state 121

    (80) matrix_factor -> ID .

    DOTMUL          reduce using rule 80 (matrix_factor -> ID .)
    DOTDIV          reduce using rule 80 (matrix_factor -> ID .)
    DOTADD          reduce using rule 80 (matrix_factor -> ID .)
    DOTSUB          reduce using rule 80 (matrix_factor -> ID .)
    '               reduce using rule 80 (matrix_factor -> ID .)
    ;               reduce using rule 80 (matrix_factor -> ID .)
    )               reduce using rule 80 (matrix_factor -> ID .)


state 122

    (73) matrix_expr -> matrix_expr DOTSUB matrix_term .
    (75) matrix_term -> matrix_term . DOTMUL matrix_factor
    (76) matrix_term -> matrix_term . DOTDIV matrix_factor

    DOTADD          reduce using rule 73 (matrix_expr -> matrix_expr DOTSUB matrix_term .)
    DOTSUB          reduce using rule 73 (matrix_expr -> matrix_expr DOTSUB matrix_term .)
    '               reduce using rule 73 (matrix_expr -> matrix_expr DOTSUB matrix_term .)
    ;               reduce using rule 73 (matrix_expr -> matrix_expr DOTSUB matrix_term .)
    )               reduce using rule 73 (matrix_expr -> matrix_expr DOTSUB matrix_term .)
    DOTMUL          shift and go to state 97
    DOTDIV          shift and go to state 98


state 123

    (61) matrix -> ONES ( int . )

    )               shift and go to state 146


state 124

    (78) matrix_factor -> ( matrix_expr ) .

    DOTMUL          reduce using rule 78 (matrix_factor -> ( matrix_expr ) .)
    DOTDIV          reduce using rule 78 (matrix_factor -> ( matrix_expr ) .)
    DOTADD          reduce using rule 78 (matrix_factor -> ( matrix_expr ) .)
    DOTSUB          reduce using rule 78 (matrix_factor -> ( matrix_expr ) .)
    '               reduce using rule 78 (matrix_factor -> ( matrix_expr ) .)
    ;               reduce using rule 78 (matrix_factor -> ( matrix_expr ) .)
    )               reduce using rule 78 (matrix_factor -> ( matrix_expr ) .)


state 125

    (62) matrix -> ZEROS ( int . )

    )               shift and go to state 147


state 126

    (63) matrix -> EYE ( int . )

    )               shift and go to state 148


state 127

    (75) matrix_term -> matrix_term DOTMUL matrix_factor .

    DOTMUL          reduce using rule 75 (matrix_term -> matrix_term DOTMUL matrix_factor .)
    DOTDIV          reduce using rule 75 (matrix_term -> matrix_term DOTMUL matrix_factor .)
    DOTADD          reduce using rule 75 (matrix_term -> matrix_term DOTMUL matrix_factor .)
    DOTSUB          reduce using rule 75 (matrix_term -> matrix_term DOTMUL matrix_factor .)
    '               reduce using rule 75 (matrix_term -> matrix_term DOTMUL matrix_factor .)
    ;               reduce using rule 75 (matrix_term -> matrix_term DOTMUL matrix_factor .)
    )               reduce using rule 75 (matrix_term -> matrix_term DOTMUL matrix_factor .)


state 128

    (76) matrix_term -> matrix_term DOTDIV matrix_factor .

    DOTMUL          reduce using rule 76 (matrix_term -> matrix_term DOTDIV matrix_factor .)
    DOTDIV          reduce using rule 76 (matrix_term -> matrix_term DOTDIV matrix_factor .)
    DOTADD          reduce using rule 76 (matrix_term -> matrix_term DOTDIV matrix_factor .)
    DOTSUB          reduce using rule 76 (matrix_term -> matrix_term DOTDIV matrix_factor .)
    '               reduce using rule 76 (matrix_term -> matrix_term DOTDIV matrix_factor .)
    ;               reduce using rule 76 (matrix_term -> matrix_term DOTDIV matrix_factor .)
    )               reduce using rule 76 (matrix_term -> matrix_term DOTDIV matrix_factor .)


state 129

    (66) outerlist -> [ innerlist . ]
    (67) innerlist -> innerlist . , elem

    ]               shift and go to state 149
    ,               shift and go to state 150


state 130

    (68) innerlist -> elem .

    ]               reduce using rule 68 (innerlist -> elem .)
    ,               reduce using rule 68 (innerlist -> elem .)


state 131

    (64) vector -> [ outerlist ] .

    ;               reduce using rule 64 (vector -> [ outerlist ] .)
    DOTMUL          reduce using rule 64 (vector -> [ outerlist ] .)
    DOTDIV          reduce using rule 64 (vector -> [ outerlist ] .)
    DOTADD          reduce using rule 64 (vector -> [ outerlist ] .)
    DOTSUB          reduce using rule 64 (vector -> [ outerlist ] .)
    '               reduce using rule 64 (vector -> [ outerlist ] .)
    )               reduce using rule 64 (vector -> [ outerlist ] .)


state 132

    (65) outerlist -> outerlist , . [ innerlist ]

    [               shift and go to state 151


state 133

    (59) MID -> ID [ INTNUM , INTNUM . ]

    ]               shift and go to state 152


state 134

    (14) if_instruction -> IF ( relational_expr ) instructions_block .
    (16) if_instruction -> IF ( relational_expr ) instructions_block . ELSE instruction
    (13) instruction -> instructions_block .

  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! reduce/reduce conflict for ID resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for IF resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for FOR resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for WHILE resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for PRINT resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for BREAK resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for RETURN resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for { resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for $end resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for } resolved using rule 13 (instruction -> instructions_block .)
    ELSE            shift and go to state 153
    ID              reduce using rule 13 (instruction -> instructions_block .)
    IF              reduce using rule 13 (instruction -> instructions_block .)
    FOR             reduce using rule 13 (instruction -> instructions_block .)
    WHILE           reduce using rule 13 (instruction -> instructions_block .)
    PRINT           reduce using rule 13 (instruction -> instructions_block .)
    BREAK           reduce using rule 13 (instruction -> instructions_block .)
    CONTINUE        reduce using rule 13 (instruction -> instructions_block .)
    RETURN          reduce using rule 13 (instruction -> instructions_block .)
    {               reduce using rule 13 (instruction -> instructions_block .)
    $end            reduce using rule 13 (instruction -> instructions_block .)
    }               reduce using rule 13 (instruction -> instructions_block .)

  ! ID              [ reduce using rule 14 (if_instruction -> IF ( relational_expr ) instructions_block .) ]
  ! IF              [ reduce using rule 14 (if_instruction -> IF ( relational_expr ) instructions_block .) ]
  ! FOR             [ reduce using rule 14 (if_instruction -> IF ( relational_expr ) instructions_block .) ]
  ! WHILE           [ reduce using rule 14 (if_instruction -> IF ( relational_expr ) instructions_block .) ]
  ! PRINT           [ reduce using rule 14 (if_instruction -> IF ( relational_expr ) instructions_block .) ]
  ! BREAK           [ reduce using rule 14 (if_instruction -> IF ( relational_expr ) instructions_block .) ]
  ! CONTINUE        [ reduce using rule 14 (if_instruction -> IF ( relational_expr ) instructions_block .) ]
  ! RETURN          [ reduce using rule 14 (if_instruction -> IF ( relational_expr ) instructions_block .) ]
  ! {               [ reduce using rule 14 (if_instruction -> IF ( relational_expr ) instructions_block .) ]
  ! $end            [ reduce using rule 14 (if_instruction -> IF ( relational_expr ) instructions_block .) ]
  ! }               [ reduce using rule 14 (if_instruction -> IF ( relational_expr ) instructions_block .) ]
  ! ELSE            [ reduce using rule 14 (if_instruction -> IF ( relational_expr ) instructions_block .) ]
  ! ELSE            [ reduce using rule 13 (instruction -> instructions_block .) ]


state 135

    (15) if_instruction -> IF ( relational_expr ) instruction .
    (17) if_instruction -> IF ( relational_expr ) instruction . ELSE instruction

  ! shift/reduce conflict for ELSE resolved as shift
    ID              reduce using rule 15 (if_instruction -> IF ( relational_expr ) instruction .)
    IF              reduce using rule 15 (if_instruction -> IF ( relational_expr ) instruction .)
    FOR             reduce using rule 15 (if_instruction -> IF ( relational_expr ) instruction .)
    WHILE           reduce using rule 15 (if_instruction -> IF ( relational_expr ) instruction .)
    PRINT           reduce using rule 15 (if_instruction -> IF ( relational_expr ) instruction .)
    BREAK           reduce using rule 15 (if_instruction -> IF ( relational_expr ) instruction .)
    CONTINUE        reduce using rule 15 (if_instruction -> IF ( relational_expr ) instruction .)
    RETURN          reduce using rule 15 (if_instruction -> IF ( relational_expr ) instruction .)
    {               reduce using rule 15 (if_instruction -> IF ( relational_expr ) instruction .)
    $end            reduce using rule 15 (if_instruction -> IF ( relational_expr ) instruction .)
    }               reduce using rule 15 (if_instruction -> IF ( relational_expr ) instruction .)
    ELSE            shift and go to state 154

  ! ELSE            [ reduce using rule 15 (if_instruction -> IF ( relational_expr ) instruction .) ]


state 136

    (53) relational_expr -> expr GREATEREQUAL expr .
    (45) expr -> expr . + term
    (46) expr -> expr . - term

    )               reduce using rule 53 (relational_expr -> expr GREATEREQUAL expr .)
    +               shift and go to state 80
    -               shift and go to state 81


state 137

    (54) relational_expr -> expr EQUALS expr .
    (45) expr -> expr . + term
    (46) expr -> expr . - term

    )               reduce using rule 54 (relational_expr -> expr EQUALS expr .)
    +               shift and go to state 80
    -               shift and go to state 81


state 138

    (55) relational_expr -> expr NOTEQUALS expr .
    (45) expr -> expr . + term
    (46) expr -> expr . - term

    )               reduce using rule 55 (relational_expr -> expr NOTEQUALS expr .)
    +               shift and go to state 80
    -               shift and go to state 81


state 139

    (56) relational_expr -> expr LOWEREQUAL expr .
    (45) expr -> expr . + term
    (46) expr -> expr . - term

    )               reduce using rule 56 (relational_expr -> expr LOWEREQUAL expr .)
    +               shift and go to state 80
    -               shift and go to state 81


state 140

    (57) relational_expr -> expr < expr .
    (45) expr -> expr . + term
    (46) expr -> expr . - term

    )               reduce using rule 57 (relational_expr -> expr < expr .)
    +               shift and go to state 80
    -               shift and go to state 81


state 141

    (58) relational_expr -> expr > expr .
    (45) expr -> expr . + term
    (46) expr -> expr . - term

    )               reduce using rule 58 (relational_expr -> expr > expr .)
    +               shift and go to state 80
    -               shift and go to state 81


state 142

    (20) for_instruction -> FOR ID = ID : . ID instructions_block
    (21) for_instruction -> FOR ID = ID : . ID instruction

    ID              shift and go to state 155


state 143

    (18) for_instruction -> FOR ID = INTNUM : . ID instructions_block
    (19) for_instruction -> FOR ID = INTNUM : . ID instruction

    ID              shift and go to state 156


state 144

    (22) while_instruction -> WHILE ( relational_expr ) instructions_block .
    (13) instruction -> instructions_block .

  ! reduce/reduce conflict for ELSE resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for ID resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for IF resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for FOR resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for WHILE resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for PRINT resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for BREAK resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for RETURN resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for { resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for $end resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for } resolved using rule 13 (instruction -> instructions_block .)
    ELSE            reduce using rule 13 (instruction -> instructions_block .)
    ID              reduce using rule 13 (instruction -> instructions_block .)
    IF              reduce using rule 13 (instruction -> instructions_block .)
    FOR             reduce using rule 13 (instruction -> instructions_block .)
    WHILE           reduce using rule 13 (instruction -> instructions_block .)
    PRINT           reduce using rule 13 (instruction -> instructions_block .)
    BREAK           reduce using rule 13 (instruction -> instructions_block .)
    CONTINUE        reduce using rule 13 (instruction -> instructions_block .)
    RETURN          reduce using rule 13 (instruction -> instructions_block .)
    {               reduce using rule 13 (instruction -> instructions_block .)
    $end            reduce using rule 13 (instruction -> instructions_block .)
    }               reduce using rule 13 (instruction -> instructions_block .)

  ! ID              [ reduce using rule 22 (while_instruction -> WHILE ( relational_expr ) instructions_block .) ]
  ! IF              [ reduce using rule 22 (while_instruction -> WHILE ( relational_expr ) instructions_block .) ]
  ! FOR             [ reduce using rule 22 (while_instruction -> WHILE ( relational_expr ) instructions_block .) ]
  ! WHILE           [ reduce using rule 22 (while_instruction -> WHILE ( relational_expr ) instructions_block .) ]
  ! PRINT           [ reduce using rule 22 (while_instruction -> WHILE ( relational_expr ) instructions_block .) ]
  ! BREAK           [ reduce using rule 22 (while_instruction -> WHILE ( relational_expr ) instructions_block .) ]
  ! CONTINUE        [ reduce using rule 22 (while_instruction -> WHILE ( relational_expr ) instructions_block .) ]
  ! RETURN          [ reduce using rule 22 (while_instruction -> WHILE ( relational_expr ) instructions_block .) ]
  ! {               [ reduce using rule 22 (while_instruction -> WHILE ( relational_expr ) instructions_block .) ]
  ! $end            [ reduce using rule 22 (while_instruction -> WHILE ( relational_expr ) instructions_block .) ]
  ! }               [ reduce using rule 22 (while_instruction -> WHILE ( relational_expr ) instructions_block .) ]
  ! ELSE            [ reduce using rule 22 (while_instruction -> WHILE ( relational_expr ) instructions_block .) ]


state 145

    (23) while_instruction -> WHILE ( relational_expr ) instruction .

    ID              reduce using rule 23 (while_instruction -> WHILE ( relational_expr ) instruction .)
    IF              reduce using rule 23 (while_instruction -> WHILE ( relational_expr ) instruction .)
    FOR             reduce using rule 23 (while_instruction -> WHILE ( relational_expr ) instruction .)
    WHILE           reduce using rule 23 (while_instruction -> WHILE ( relational_expr ) instruction .)
    PRINT           reduce using rule 23 (while_instruction -> WHILE ( relational_expr ) instruction .)
    BREAK           reduce using rule 23 (while_instruction -> WHILE ( relational_expr ) instruction .)
    CONTINUE        reduce using rule 23 (while_instruction -> WHILE ( relational_expr ) instruction .)
    RETURN          reduce using rule 23 (while_instruction -> WHILE ( relational_expr ) instruction .)
    {               reduce using rule 23 (while_instruction -> WHILE ( relational_expr ) instruction .)
    $end            reduce using rule 23 (while_instruction -> WHILE ( relational_expr ) instruction .)
    }               reduce using rule 23 (while_instruction -> WHILE ( relational_expr ) instruction .)
    ELSE            reduce using rule 23 (while_instruction -> WHILE ( relational_expr ) instruction .)


state 146

    (61) matrix -> ONES ( int ) .

    ;               reduce using rule 61 (matrix -> ONES ( int ) .)
    DOTMUL          reduce using rule 61 (matrix -> ONES ( int ) .)
    DOTDIV          reduce using rule 61 (matrix -> ONES ( int ) .)
    DOTADD          reduce using rule 61 (matrix -> ONES ( int ) .)
    DOTSUB          reduce using rule 61 (matrix -> ONES ( int ) .)
    '               reduce using rule 61 (matrix -> ONES ( int ) .)
    )               reduce using rule 61 (matrix -> ONES ( int ) .)


state 147

    (62) matrix -> ZEROS ( int ) .

    ;               reduce using rule 62 (matrix -> ZEROS ( int ) .)
    DOTMUL          reduce using rule 62 (matrix -> ZEROS ( int ) .)
    DOTDIV          reduce using rule 62 (matrix -> ZEROS ( int ) .)
    DOTADD          reduce using rule 62 (matrix -> ZEROS ( int ) .)
    DOTSUB          reduce using rule 62 (matrix -> ZEROS ( int ) .)
    '               reduce using rule 62 (matrix -> ZEROS ( int ) .)
    )               reduce using rule 62 (matrix -> ZEROS ( int ) .)


state 148

    (63) matrix -> EYE ( int ) .

    ;               reduce using rule 63 (matrix -> EYE ( int ) .)
    DOTMUL          reduce using rule 63 (matrix -> EYE ( int ) .)
    DOTDIV          reduce using rule 63 (matrix -> EYE ( int ) .)
    DOTADD          reduce using rule 63 (matrix -> EYE ( int ) .)
    DOTSUB          reduce using rule 63 (matrix -> EYE ( int ) .)
    '               reduce using rule 63 (matrix -> EYE ( int ) .)
    )               reduce using rule 63 (matrix -> EYE ( int ) .)


state 149

    (66) outerlist -> [ innerlist ] .

    ]               reduce using rule 66 (outerlist -> [ innerlist ] .)
    ,               reduce using rule 66 (outerlist -> [ innerlist ] .)


state 150

    (67) innerlist -> innerlist , . elem
    (69) elem -> . ID
    (70) elem -> . int
    (71) elem -> . float
    (83) int -> . INTNUM
    (84) float -> . FLONUM

    ID              shift and go to state 42
    INTNUM          shift and go to state 45
    FLONUM          shift and go to state 46

    elem                           shift and go to state 157
    int                            shift and go to state 43
    float                          shift and go to state 44

state 151

    (65) outerlist -> outerlist , [ . innerlist ]
    (67) innerlist -> . innerlist , elem
    (68) innerlist -> . elem
    (69) elem -> . ID
    (70) elem -> . int
    (71) elem -> . float
    (83) int -> . INTNUM
    (84) float -> . FLONUM

    ID              shift and go to state 42
    INTNUM          shift and go to state 45
    FLONUM          shift and go to state 46

    innerlist                      shift and go to state 158
    elem                           shift and go to state 130
    int                            shift and go to state 43
    float                          shift and go to state 44

state 152

    (59) MID -> ID [ INTNUM , INTNUM ] .

    =               reduce using rule 59 (MID -> ID [ INTNUM , INTNUM ] .)


state 153

    (16) if_instruction -> IF ( relational_expr ) instructions_block ELSE . instruction
    (6) instruction -> . assignment ;
    (7) instruction -> . if_instruction
    (8) instruction -> . for_instruction
    (9) instruction -> . while_instruction
    (10) instruction -> . print_instruction
    (11) instruction -> . loop_instruction
    (12) instruction -> . return_instruction
    (13) instruction -> . instructions_block
    (32) assignment -> . ID = token
    (33) assignment -> . ID ADDASSIGN token
    (34) assignment -> . ID SUBASSIGN token
    (35) assignment -> . ID MULASSIGN token
    (36) assignment -> . ID DIVASSIGN token
    (37) assignment -> . MID = elem
    (14) if_instruction -> . IF ( relational_expr ) instructions_block
    (15) if_instruction -> . IF ( relational_expr ) instruction
    (16) if_instruction -> . IF ( relational_expr ) instructions_block ELSE instruction
    (17) if_instruction -> . IF ( relational_expr ) instruction ELSE instruction
    (18) for_instruction -> . FOR ID = INTNUM : ID instructions_block
    (19) for_instruction -> . FOR ID = INTNUM : ID instruction
    (20) for_instruction -> . FOR ID = ID : ID instructions_block
    (21) for_instruction -> . FOR ID = ID : ID instruction
    (22) while_instruction -> . WHILE ( relational_expr ) instructions_block
    (23) while_instruction -> . WHILE ( relational_expr ) instruction
    (27) print_instruction -> . PRINT print_list ;
    (24) loop_instruction -> . BREAK ;
    (25) loop_instruction -> . CONTINUE ;
    (26) return_instruction -> . RETURN expr ;
    (3) instructions_block -> . { instructions }
    (59) MID -> . ID [ INTNUM , INTNUM ]

    ID              shift and go to state 13
    IF              shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    PRINT           shift and go to state 18
    BREAK           shift and go to state 19
    CONTINUE        shift and go to state 20
    RETURN          shift and go to state 21
    {               shift and go to state 22

    instructions_block             shift and go to state 12
    instruction                    shift and go to state 159
    assignment                     shift and go to state 5
    if_instruction                 shift and go to state 6
    for_instruction                shift and go to state 7
    while_instruction              shift and go to state 8
    print_instruction              shift and go to state 9
    loop_instruction               shift and go to state 10
    return_instruction             shift and go to state 11
    MID                            shift and go to state 14

state 154

    (17) if_instruction -> IF ( relational_expr ) instruction ELSE . instruction
    (6) instruction -> . assignment ;
    (7) instruction -> . if_instruction
    (8) instruction -> . for_instruction
    (9) instruction -> . while_instruction
    (10) instruction -> . print_instruction
    (11) instruction -> . loop_instruction
    (12) instruction -> . return_instruction
    (13) instruction -> . instructions_block
    (32) assignment -> . ID = token
    (33) assignment -> . ID ADDASSIGN token
    (34) assignment -> . ID SUBASSIGN token
    (35) assignment -> . ID MULASSIGN token
    (36) assignment -> . ID DIVASSIGN token
    (37) assignment -> . MID = elem
    (14) if_instruction -> . IF ( relational_expr ) instructions_block
    (15) if_instruction -> . IF ( relational_expr ) instruction
    (16) if_instruction -> . IF ( relational_expr ) instructions_block ELSE instruction
    (17) if_instruction -> . IF ( relational_expr ) instruction ELSE instruction
    (18) for_instruction -> . FOR ID = INTNUM : ID instructions_block
    (19) for_instruction -> . FOR ID = INTNUM : ID instruction
    (20) for_instruction -> . FOR ID = ID : ID instructions_block
    (21) for_instruction -> . FOR ID = ID : ID instruction
    (22) while_instruction -> . WHILE ( relational_expr ) instructions_block
    (23) while_instruction -> . WHILE ( relational_expr ) instruction
    (27) print_instruction -> . PRINT print_list ;
    (24) loop_instruction -> . BREAK ;
    (25) loop_instruction -> . CONTINUE ;
    (26) return_instruction -> . RETURN expr ;
    (3) instructions_block -> . { instructions }
    (59) MID -> . ID [ INTNUM , INTNUM ]

    ID              shift and go to state 13
    IF              shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    PRINT           shift and go to state 18
    BREAK           shift and go to state 19
    CONTINUE        shift and go to state 20
    RETURN          shift and go to state 21
    {               shift and go to state 22

    instruction                    shift and go to state 160
    assignment                     shift and go to state 5
    if_instruction                 shift and go to state 6
    for_instruction                shift and go to state 7
    while_instruction              shift and go to state 8
    print_instruction              shift and go to state 9
    loop_instruction               shift and go to state 10
    return_instruction             shift and go to state 11
    instructions_block             shift and go to state 12
    MID                            shift and go to state 14

state 155

    (20) for_instruction -> FOR ID = ID : ID . instructions_block
    (21) for_instruction -> FOR ID = ID : ID . instruction
    (3) instructions_block -> . { instructions }
    (6) instruction -> . assignment ;
    (7) instruction -> . if_instruction
    (8) instruction -> . for_instruction
    (9) instruction -> . while_instruction
    (10) instruction -> . print_instruction
    (11) instruction -> . loop_instruction
    (12) instruction -> . return_instruction
    (13) instruction -> . instructions_block
    (32) assignment -> . ID = token
    (33) assignment -> . ID ADDASSIGN token
    (34) assignment -> . ID SUBASSIGN token
    (35) assignment -> . ID MULASSIGN token
    (36) assignment -> . ID DIVASSIGN token
    (37) assignment -> . MID = elem
    (14) if_instruction -> . IF ( relational_expr ) instructions_block
    (15) if_instruction -> . IF ( relational_expr ) instruction
    (16) if_instruction -> . IF ( relational_expr ) instructions_block ELSE instruction
    (17) if_instruction -> . IF ( relational_expr ) instruction ELSE instruction
    (18) for_instruction -> . FOR ID = INTNUM : ID instructions_block
    (19) for_instruction -> . FOR ID = INTNUM : ID instruction
    (20) for_instruction -> . FOR ID = ID : ID instructions_block
    (21) for_instruction -> . FOR ID = ID : ID instruction
    (22) while_instruction -> . WHILE ( relational_expr ) instructions_block
    (23) while_instruction -> . WHILE ( relational_expr ) instruction
    (27) print_instruction -> . PRINT print_list ;
    (24) loop_instruction -> . BREAK ;
    (25) loop_instruction -> . CONTINUE ;
    (26) return_instruction -> . RETURN expr ;
    (59) MID -> . ID [ INTNUM , INTNUM ]

    {               shift and go to state 22
    ID              shift and go to state 13
    IF              shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    PRINT           shift and go to state 18
    BREAK           shift and go to state 19
    CONTINUE        shift and go to state 20
    RETURN          shift and go to state 21

    instructions_block             shift and go to state 161
    instruction                    shift and go to state 162
    assignment                     shift and go to state 5
    if_instruction                 shift and go to state 6
    for_instruction                shift and go to state 7
    while_instruction              shift and go to state 8
    print_instruction              shift and go to state 9
    loop_instruction               shift and go to state 10
    return_instruction             shift and go to state 11
    MID                            shift and go to state 14

state 156

    (18) for_instruction -> FOR ID = INTNUM : ID . instructions_block
    (19) for_instruction -> FOR ID = INTNUM : ID . instruction
    (3) instructions_block -> . { instructions }
    (6) instruction -> . assignment ;
    (7) instruction -> . if_instruction
    (8) instruction -> . for_instruction
    (9) instruction -> . while_instruction
    (10) instruction -> . print_instruction
    (11) instruction -> . loop_instruction
    (12) instruction -> . return_instruction
    (13) instruction -> . instructions_block
    (32) assignment -> . ID = token
    (33) assignment -> . ID ADDASSIGN token
    (34) assignment -> . ID SUBASSIGN token
    (35) assignment -> . ID MULASSIGN token
    (36) assignment -> . ID DIVASSIGN token
    (37) assignment -> . MID = elem
    (14) if_instruction -> . IF ( relational_expr ) instructions_block
    (15) if_instruction -> . IF ( relational_expr ) instruction
    (16) if_instruction -> . IF ( relational_expr ) instructions_block ELSE instruction
    (17) if_instruction -> . IF ( relational_expr ) instruction ELSE instruction
    (18) for_instruction -> . FOR ID = INTNUM : ID instructions_block
    (19) for_instruction -> . FOR ID = INTNUM : ID instruction
    (20) for_instruction -> . FOR ID = ID : ID instructions_block
    (21) for_instruction -> . FOR ID = ID : ID instruction
    (22) while_instruction -> . WHILE ( relational_expr ) instructions_block
    (23) while_instruction -> . WHILE ( relational_expr ) instruction
    (27) print_instruction -> . PRINT print_list ;
    (24) loop_instruction -> . BREAK ;
    (25) loop_instruction -> . CONTINUE ;
    (26) return_instruction -> . RETURN expr ;
    (59) MID -> . ID [ INTNUM , INTNUM ]

    {               shift and go to state 22
    ID              shift and go to state 13
    IF              shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17
    PRINT           shift and go to state 18
    BREAK           shift and go to state 19
    CONTINUE        shift and go to state 20
    RETURN          shift and go to state 21

    instructions_block             shift and go to state 163
    instruction                    shift and go to state 164
    assignment                     shift and go to state 5
    if_instruction                 shift and go to state 6
    for_instruction                shift and go to state 7
    while_instruction              shift and go to state 8
    print_instruction              shift and go to state 9
    loop_instruction               shift and go to state 10
    return_instruction             shift and go to state 11
    MID                            shift and go to state 14

state 157

    (67) innerlist -> innerlist , elem .

    ]               reduce using rule 67 (innerlist -> innerlist , elem .)
    ,               reduce using rule 67 (innerlist -> innerlist , elem .)


state 158

    (65) outerlist -> outerlist , [ innerlist . ]
    (67) innerlist -> innerlist . , elem

    ]               shift and go to state 165
    ,               shift and go to state 150


state 159

    (16) if_instruction -> IF ( relational_expr ) instructions_block ELSE instruction .

    ID              reduce using rule 16 (if_instruction -> IF ( relational_expr ) instructions_block ELSE instruction .)
    IF              reduce using rule 16 (if_instruction -> IF ( relational_expr ) instructions_block ELSE instruction .)
    FOR             reduce using rule 16 (if_instruction -> IF ( relational_expr ) instructions_block ELSE instruction .)
    WHILE           reduce using rule 16 (if_instruction -> IF ( relational_expr ) instructions_block ELSE instruction .)
    PRINT           reduce using rule 16 (if_instruction -> IF ( relational_expr ) instructions_block ELSE instruction .)
    BREAK           reduce using rule 16 (if_instruction -> IF ( relational_expr ) instructions_block ELSE instruction .)
    CONTINUE        reduce using rule 16 (if_instruction -> IF ( relational_expr ) instructions_block ELSE instruction .)
    RETURN          reduce using rule 16 (if_instruction -> IF ( relational_expr ) instructions_block ELSE instruction .)
    {               reduce using rule 16 (if_instruction -> IF ( relational_expr ) instructions_block ELSE instruction .)
    $end            reduce using rule 16 (if_instruction -> IF ( relational_expr ) instructions_block ELSE instruction .)
    }               reduce using rule 16 (if_instruction -> IF ( relational_expr ) instructions_block ELSE instruction .)
    ELSE            reduce using rule 16 (if_instruction -> IF ( relational_expr ) instructions_block ELSE instruction .)


state 160

    (17) if_instruction -> IF ( relational_expr ) instruction ELSE instruction .

    ID              reduce using rule 17 (if_instruction -> IF ( relational_expr ) instruction ELSE instruction .)
    IF              reduce using rule 17 (if_instruction -> IF ( relational_expr ) instruction ELSE instruction .)
    FOR             reduce using rule 17 (if_instruction -> IF ( relational_expr ) instruction ELSE instruction .)
    WHILE           reduce using rule 17 (if_instruction -> IF ( relational_expr ) instruction ELSE instruction .)
    PRINT           reduce using rule 17 (if_instruction -> IF ( relational_expr ) instruction ELSE instruction .)
    BREAK           reduce using rule 17 (if_instruction -> IF ( relational_expr ) instruction ELSE instruction .)
    CONTINUE        reduce using rule 17 (if_instruction -> IF ( relational_expr ) instruction ELSE instruction .)
    RETURN          reduce using rule 17 (if_instruction -> IF ( relational_expr ) instruction ELSE instruction .)
    {               reduce using rule 17 (if_instruction -> IF ( relational_expr ) instruction ELSE instruction .)
    $end            reduce using rule 17 (if_instruction -> IF ( relational_expr ) instruction ELSE instruction .)
    }               reduce using rule 17 (if_instruction -> IF ( relational_expr ) instruction ELSE instruction .)
    ELSE            reduce using rule 17 (if_instruction -> IF ( relational_expr ) instruction ELSE instruction .)


state 161

    (20) for_instruction -> FOR ID = ID : ID instructions_block .
    (13) instruction -> instructions_block .

  ! reduce/reduce conflict for ELSE resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for ID resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for IF resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for FOR resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for WHILE resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for PRINT resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for BREAK resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for RETURN resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for { resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for $end resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for } resolved using rule 13 (instruction -> instructions_block .)
    ELSE            reduce using rule 13 (instruction -> instructions_block .)
    ID              reduce using rule 13 (instruction -> instructions_block .)
    IF              reduce using rule 13 (instruction -> instructions_block .)
    FOR             reduce using rule 13 (instruction -> instructions_block .)
    WHILE           reduce using rule 13 (instruction -> instructions_block .)
    PRINT           reduce using rule 13 (instruction -> instructions_block .)
    BREAK           reduce using rule 13 (instruction -> instructions_block .)
    CONTINUE        reduce using rule 13 (instruction -> instructions_block .)
    RETURN          reduce using rule 13 (instruction -> instructions_block .)
    {               reduce using rule 13 (instruction -> instructions_block .)
    $end            reduce using rule 13 (instruction -> instructions_block .)
    }               reduce using rule 13 (instruction -> instructions_block .)

  ! ID              [ reduce using rule 20 (for_instruction -> FOR ID = ID : ID instructions_block .) ]
  ! IF              [ reduce using rule 20 (for_instruction -> FOR ID = ID : ID instructions_block .) ]
  ! FOR             [ reduce using rule 20 (for_instruction -> FOR ID = ID : ID instructions_block .) ]
  ! WHILE           [ reduce using rule 20 (for_instruction -> FOR ID = ID : ID instructions_block .) ]
  ! PRINT           [ reduce using rule 20 (for_instruction -> FOR ID = ID : ID instructions_block .) ]
  ! BREAK           [ reduce using rule 20 (for_instruction -> FOR ID = ID : ID instructions_block .) ]
  ! CONTINUE        [ reduce using rule 20 (for_instruction -> FOR ID = ID : ID instructions_block .) ]
  ! RETURN          [ reduce using rule 20 (for_instruction -> FOR ID = ID : ID instructions_block .) ]
  ! {               [ reduce using rule 20 (for_instruction -> FOR ID = ID : ID instructions_block .) ]
  ! $end            [ reduce using rule 20 (for_instruction -> FOR ID = ID : ID instructions_block .) ]
  ! }               [ reduce using rule 20 (for_instruction -> FOR ID = ID : ID instructions_block .) ]
  ! ELSE            [ reduce using rule 20 (for_instruction -> FOR ID = ID : ID instructions_block .) ]


state 162

    (21) for_instruction -> FOR ID = ID : ID instruction .

    ID              reduce using rule 21 (for_instruction -> FOR ID = ID : ID instruction .)
    IF              reduce using rule 21 (for_instruction -> FOR ID = ID : ID instruction .)
    FOR             reduce using rule 21 (for_instruction -> FOR ID = ID : ID instruction .)
    WHILE           reduce using rule 21 (for_instruction -> FOR ID = ID : ID instruction .)
    PRINT           reduce using rule 21 (for_instruction -> FOR ID = ID : ID instruction .)
    BREAK           reduce using rule 21 (for_instruction -> FOR ID = ID : ID instruction .)
    CONTINUE        reduce using rule 21 (for_instruction -> FOR ID = ID : ID instruction .)
    RETURN          reduce using rule 21 (for_instruction -> FOR ID = ID : ID instruction .)
    {               reduce using rule 21 (for_instruction -> FOR ID = ID : ID instruction .)
    $end            reduce using rule 21 (for_instruction -> FOR ID = ID : ID instruction .)
    }               reduce using rule 21 (for_instruction -> FOR ID = ID : ID instruction .)
    ELSE            reduce using rule 21 (for_instruction -> FOR ID = ID : ID instruction .)


state 163

    (18) for_instruction -> FOR ID = INTNUM : ID instructions_block .
    (13) instruction -> instructions_block .

  ! reduce/reduce conflict for ELSE resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for ID resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for IF resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for FOR resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for WHILE resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for PRINT resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for BREAK resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for RETURN resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for { resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for $end resolved using rule 13 (instruction -> instructions_block .)
  ! reduce/reduce conflict for } resolved using rule 13 (instruction -> instructions_block .)
    ELSE            reduce using rule 13 (instruction -> instructions_block .)
    ID              reduce using rule 13 (instruction -> instructions_block .)
    IF              reduce using rule 13 (instruction -> instructions_block .)
    FOR             reduce using rule 13 (instruction -> instructions_block .)
    WHILE           reduce using rule 13 (instruction -> instructions_block .)
    PRINT           reduce using rule 13 (instruction -> instructions_block .)
    BREAK           reduce using rule 13 (instruction -> instructions_block .)
    CONTINUE        reduce using rule 13 (instruction -> instructions_block .)
    RETURN          reduce using rule 13 (instruction -> instructions_block .)
    {               reduce using rule 13 (instruction -> instructions_block .)
    $end            reduce using rule 13 (instruction -> instructions_block .)
    }               reduce using rule 13 (instruction -> instructions_block .)

  ! ID              [ reduce using rule 18 (for_instruction -> FOR ID = INTNUM : ID instructions_block .) ]
  ! IF              [ reduce using rule 18 (for_instruction -> FOR ID = INTNUM : ID instructions_block .) ]
  ! FOR             [ reduce using rule 18 (for_instruction -> FOR ID = INTNUM : ID instructions_block .) ]
  ! WHILE           [ reduce using rule 18 (for_instruction -> FOR ID = INTNUM : ID instructions_block .) ]
  ! PRINT           [ reduce using rule 18 (for_instruction -> FOR ID = INTNUM : ID instructions_block .) ]
  ! BREAK           [ reduce using rule 18 (for_instruction -> FOR ID = INTNUM : ID instructions_block .) ]
  ! CONTINUE        [ reduce using rule 18 (for_instruction -> FOR ID = INTNUM : ID instructions_block .) ]
  ! RETURN          [ reduce using rule 18 (for_instruction -> FOR ID = INTNUM : ID instructions_block .) ]
  ! {               [ reduce using rule 18 (for_instruction -> FOR ID = INTNUM : ID instructions_block .) ]
  ! $end            [ reduce using rule 18 (for_instruction -> FOR ID = INTNUM : ID instructions_block .) ]
  ! }               [ reduce using rule 18 (for_instruction -> FOR ID = INTNUM : ID instructions_block .) ]
  ! ELSE            [ reduce using rule 18 (for_instruction -> FOR ID = INTNUM : ID instructions_block .) ]


state 164

    (19) for_instruction -> FOR ID = INTNUM : ID instruction .

    ID              reduce using rule 19 (for_instruction -> FOR ID = INTNUM : ID instruction .)
    IF              reduce using rule 19 (for_instruction -> FOR ID = INTNUM : ID instruction .)
    FOR             reduce using rule 19 (for_instruction -> FOR ID = INTNUM : ID instruction .)
    WHILE           reduce using rule 19 (for_instruction -> FOR ID = INTNUM : ID instruction .)
    PRINT           reduce using rule 19 (for_instruction -> FOR ID = INTNUM : ID instruction .)
    BREAK           reduce using rule 19 (for_instruction -> FOR ID = INTNUM : ID instruction .)
    CONTINUE        reduce using rule 19 (for_instruction -> FOR ID = INTNUM : ID instruction .)
    RETURN          reduce using rule 19 (for_instruction -> FOR ID = INTNUM : ID instruction .)
    {               reduce using rule 19 (for_instruction -> FOR ID = INTNUM : ID instruction .)
    $end            reduce using rule 19 (for_instruction -> FOR ID = INTNUM : ID instruction .)
    }               reduce using rule 19 (for_instruction -> FOR ID = INTNUM : ID instruction .)
    ELSE            reduce using rule 19 (for_instruction -> FOR ID = INTNUM : ID instruction .)


state 165

    (65) outerlist -> outerlist , [ innerlist ] .

    ]               reduce using rule 65 (outerlist -> outerlist , [ innerlist ] .)
    ,               reduce using rule 65 (outerlist -> outerlist , [ innerlist ] .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 134 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 134 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 135 resolved as shift
WARNING: reduce/reduce conflict in state 51 resolved using rule (token -> ID)
WARNING: rejected rule (matrix_factor -> ID) in state 51
WARNING: reduce/reduce conflict in state 51 resolved using rule (token -> ID)
WARNING: rejected rule (elem -> ID) in state 51
WARNING: reduce/reduce conflict in state 53 resolved using rule (token -> int)
WARNING: rejected rule (elem -> int) in state 53
WARNING: reduce/reduce conflict in state 54 resolved using rule (token -> float)
WARNING: rejected rule (elem -> float) in state 54
WARNING: reduce/reduce conflict in state 55 resolved using rule (token -> matrix)
WARNING: rejected rule (matrix_factor -> matrix) in state 55
WARNING: reduce/reduce conflict in state 93 resolved using rule (elem -> ID)
WARNING: rejected rule (matrix_factor -> ID) in state 93
WARNING: reduce/reduce conflict in state 134 resolved using rule (instruction -> instructions_block)
WARNING: rejected rule (if_instruction -> IF ( relational_expr ) instructions_block) in state 134
WARNING: reduce/reduce conflict in state 144 resolved using rule (instruction -> instructions_block)
WARNING: rejected rule (while_instruction -> WHILE ( relational_expr ) instructions_block) in state 144
WARNING: reduce/reduce conflict in state 161 resolved using rule (instruction -> instructions_block)
WARNING: rejected rule (for_instruction -> FOR ID = ID : ID instructions_block) in state 161
WARNING: reduce/reduce conflict in state 163 resolved using rule (instruction -> instructions_block)
WARNING: rejected rule (for_instruction -> FOR ID = INTNUM : ID instructions_block) in state 163
WARNING: Rule (if_instruction -> IF ( relational_expr ) instructions_block) is never reduced
WARNING: Rule (while_instruction -> WHILE ( relational_expr ) instructions_block) is never reduced
WARNING: Rule (for_instruction -> FOR ID = ID : ID instructions_block) is never reduced
WARNING: Rule (for_instruction -> FOR ID = INTNUM : ID instructions_block) is never reduced
